// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

#pragma warning disable CS0109 // Member does not hide an inherited member; new keyword is not required

namespace Vpx
{
    /// <summary>Algorithm return codes</summary>
    public enum VpxCodecErrT
    {
        /// <summary>Operation completed without error</summary>
        VPX_CODEC_OK = 0,
        /// <summary>Unspecified error</summary>
        VPX_CODEC_ERROR = 1,
        /// <summary>Memory operation failed</summary>
        VPX_CODEC_MEM_ERROR = 2,
        /// <summary>ABI version mismatch</summary>
        VPX_CODEC_ABI_MISMATCH = 3,
        /// <summary>Algorithm does not have required capability</summary>
        VPX_CODEC_INCAPABLE = 4,
        /// <summary>The given bitstream is not supported.</summary>
        /// <remarks>
        /// <para>The bitstream was unable to be parsed at the highest level. The decoder</para>
        /// <para>is unable to proceed. This errorbe treated as fatal to the</para>
        /// <para>stream.</para>
        /// </remarks>
        VPX_CODEC_UNSUP_BITSTREAM = 5,
        /// <summary>Encoded bitstream uses an unsupported feature</summary>
        /// <remarks>
        /// <para>The decoder does not implement a feature required by the encoder. This</para>
        /// <para>return code should only be used for features that prevent future</para>
        /// <para>pictures from being properly decoded. This errorbe treated as</para>
        /// <para>fatal to the stream orbe treated as fatal to the current GOP.</para>
        /// </remarks>
        VPX_CODEC_UNSUP_FEATURE = 6,
        /// <summary>The coded data for this stream is corrupt or incomplete</summary>
        /// <remarks>
        /// <para>There was a problem decoding the current frame.  This return code</para>
        /// <para>should only be used for failures that prevent future pictures from</para>
        /// <para>being properly decoded. This errorbe treated as fatal to the</para>
        /// <para>stream orbe treated as fatal to the current GOP. If decoding</para>
        /// <para>is continued for the current GOP, artifacts may be present.</para>
        /// </remarks>
        VPX_CODEC_CORRUPT_FRAME = 7,
        /// <summary>An application-supplied parameter is not valid.</summary>
        VPX_CODEC_INVALID_PARAM = 8,
        /// <summary>An iterator reached the end of list.</summary>
        VPX_CODEC_LIST_END = 9
    }

    /// <summary>
    /// <para>Bit depth for codec</para>
    /// <para>*</para>
    /// <para>This enumeration determines the bit depth of the codec.</para>
    /// </summary>
    public enum VpxBitDepth
    {
        /// <summary>8 bits</summary>
        VPX_BITS_8 = 8,
        /// <summary>10 bits</summary>
        VPX_BITS_10 = 10,
        /// <summary>12 bits</summary>
        VPX_BITS_12 = 12
    }

    /// <summary>Algorithm return codes</summary>
    /// <summary>Codec capabilities bitfield</summary>
    /// <remarks>
    /// <para>Each codec advertises the capabilities it supports as part of its</para>
    /// <para>::vpx_codec_iface_t interface structure. Capabilities are extra interfaces</para>
    /// <para>or functionality, and are not required to be supported.</para>
    /// <para>The available flags are specified by VPX_CODEC_CAP_* defines.</para>
    /// </remarks>
    /// <summary>Initialization-time Feature Enabling</summary>
    /// <remarks>
    /// <para>Certain codec features must be known at initialization time, to allow for</para>
    /// <para>proper memory allocation.</para>
    /// <para>The available flags are specified by VPX_CODEC_USE_* defines.</para>
    /// </remarks>
    /// <summary>Iterator</summary>
    /// <remarks>Opaque storage used for iterating over lists.</remarks>
    /// <summary>Codec context structure</summary>
    /// <remarks>
    /// <para>All codecssupport this context structure fully. In general,</para>
    /// <para>this data should be considered private to the codec algorithm, and</para>
    /// <para>not be manipulated or examined by the calling application. Applications</para>
    /// <para>may reference the 'name' member to get a printable description of the</para>
    /// <para>algorithm.</para>
    /// </remarks>
    /// <summary>
    /// <para>Bit depth for codec</para>
    /// <para>*</para>
    /// <para>This enumeration determines the bit depth of the codec.</para>
    /// </summary>
    public unsafe partial class VpxCodecIface
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecIface> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecIface>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxCodecIface managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxCodecIface managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxCodecIface __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxCodecIface(native.ToPointer(), skipVTables);
        }

        internal static VpxCodecIface __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxCodecIface)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxCodecIface __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxCodecIface(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxCodecIface(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxCodecIface(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VpxCodecPriv
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecPriv> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecPriv>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxCodecPriv managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxCodecPriv managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxCodecPriv __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxCodecPriv(native.ToPointer(), skipVTables);
        }

        internal static VpxCodecPriv __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxCodecPriv)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxCodecPriv __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxCodecPriv(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxCodecPriv(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxCodecPriv(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>Codec context structure</summary>
    /// <remarks>
    /// <para>All codecssupport this context structure fully. In general,</para>
    /// <para>this data should be considered private to the codec algorithm, and</para>
    /// <para>not be manipulated or examined by the calling application. Applications</para>
    /// <para>may reference the 'name' member to get a printable description of the</para>
    /// <para>algorithm.</para>
    /// </remarks>
    public unsafe partial class VpxCodecCtx : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal __IntPtr name;
            internal __IntPtr iface;
            internal global::Vpx.VpxCodecErrT err;
            internal __IntPtr err_detail;
            internal int init_flags;
            internal global::Vpx.VpxCodecCtx.Config.__Internal config;
            internal __IntPtr priv;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_codec_ctx@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial struct Config
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal __IntPtr dec;

                [FieldOffset(0)]
                internal __IntPtr enc;

                [FieldOffset(0)]
                internal __IntPtr raw;

                [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0<unnamed-type-config>@vpx_codec_ctx@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            private Config.__Internal __instance;
            internal ref Config.__Internal __Instance => ref __instance;

            internal static Config __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Config(native.ToPointer(), skipVTables);
            }

            internal static Config __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Config(native, skipVTables);
            }

            private Config(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Config(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::Vpx.VpxCodecCtx.Config.__Internal*) native;
            }

            public Config(global::Vpx.VpxCodecCtx.Config _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            public global::Vpx.VpxCodecDecCfg Dec
            {
                get
                {
                    var __result0 = global::Vpx.VpxCodecDecCfg.__GetOrCreateInstance(__instance.dec, false);
                    return __result0;
                }
            }

            public global::Vpx.VpxCodecEncCfg Enc
            {
                get
                {
                    var __result0 = global::Vpx.VpxCodecEncCfg.__GetOrCreateInstance(__instance.enc, false);
                    return __result0;
                }
            }

            public __IntPtr Raw
            {
                get
                {
                    return __instance.raw;
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecCtx> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecCtx>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxCodecCtx managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxCodecCtx managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        private bool __name_OwnsNativeMemory = false;
        private bool __err_detail_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static VpxCodecCtx __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxCodecCtx(native.ToPointer(), skipVTables);
        }

        internal static VpxCodecCtx __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxCodecCtx)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxCodecCtx __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxCodecCtx(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxCodecCtx(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxCodecCtx(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxCodecCtx()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxCodecCtx.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxCodecCtx(global::Vpx.VpxCodecCtx _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxCodecCtx.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxCodecCtx.__Internal*) __Instance) = *((global::Vpx.VpxCodecCtx.__Internal*) _0.__Instance);
            if (_0.__name_OwnsNativeMemory)
                this.Name = _0.Name;
            if (_0.__err_detail_OwnsNativeMemory)
                this.ErrDetail = _0.ErrDetail;
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__name_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
            if (__err_detail_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->err_detail);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Printable interface name</summary>
        public string Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->name);
            }

            set
            {
                if (__name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
                __name_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->name = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->name = (__IntPtr) __bytePtr0;
            }
        }

        /// <summary>Interface pointers</summary>
        public global::Vpx.VpxCodecIface Iface
        {
            get
            {
                var __result0 = global::Vpx.VpxCodecIface.__GetOrCreateInstance(((__Internal*)__Instance)->iface, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->iface = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>Last returned error</summary>
        public global::Vpx.VpxCodecErrT Err
        {
            get
            {
                return ((__Internal*)__Instance)->err;
            }

            set
            {
                ((__Internal*)__Instance)->err = value;
            }
        }

        /// <summary>Detailed info, if available</summary>
        public string ErrDetail
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->err_detail);
            }

            set
            {
                if (__err_detail_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->err_detail);
                __err_detail_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->err_detail = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->err_detail = (__IntPtr) __bytePtr0;
            }
        }

        /// <summary>Flags passed at init time</summary>
        public int InitFlags
        {
            get
            {
                return ((__Internal*)__Instance)->init_flags;
            }

            set
            {
                ((__Internal*)__Instance)->init_flags = value;
            }
        }

        /// <summary>Configuration pointer aliasing union</summary>
        public global::Vpx.VpxCodecCtx.Config config
        {
            get
            {
                return global::Vpx.VpxCodecCtx.Config.__CreateInstance(((__Internal*)__Instance)->config);
            }

            set
            {
                ((__Internal*)__Instance)->config = value.__Instance;
            }
        }

        /// <summary>Algorithm private storage</summary>
        public global::Vpx.VpxCodecPriv Priv
        {
            get
            {
                var __result0 = global::Vpx.VpxCodecPriv.__GetOrCreateInstance(((__Internal*)__Instance)->priv, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->priv = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class vpx_codec
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_version", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int VpxCodecVersion();

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_version_str", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr VpxCodecVersionStr();

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_version_extra_str", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr VpxCodecVersionExtraStr();

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_build_config", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr VpxCodecBuildConfig();

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_iface_name", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr VpxCodecIfaceName(__IntPtr iface);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_err_to_string", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr VpxCodecErrToString(global::Vpx.VpxCodecErrT err);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_error", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr VpxCodecError(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_error_detail", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr VpxCodecErrorDetail(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_destroy", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecDestroy(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_get_caps", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int VpxCodecGetCaps(__IntPtr iface);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_control_", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControl(__IntPtr ctx, int ctrl_id);
        }

        /// <summary>Return the version information (as an integer)</summary>
        /// <remarks>
        /// <para>Returns a packed encoding of the library version number. This will only</para>
        /// <para>include</para>
        /// <para>the major.minor.patch component of the version number. Note that this encoded</para>
        /// <para>value should be accessed through the macros provided, as the encoding may</para>
        /// <para>change</para>
        /// <para>in the future.</para>
        /// </remarks>
        public static int VpxCodecVersion()
        {
            var ___ret = __Internal.VpxCodecVersion();
            return ___ret;
        }

        /// <summary>Return the version information (as a string)</summary>
        /// <remarks>
        /// <para>Returns a printable string containing the full library version number. This</para>
        /// <para>may</para>
        /// <para>contain additional text following the three digit version number, as to</para>
        /// <para>indicate</para>
        /// <para>release candidates, prerelease versions, etc.</para>
        /// </remarks>
        public static string VpxCodecVersionStr()
        {
            var ___ret = __Internal.VpxCodecVersionStr();
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Return the version information (as a string)</summary>
        /// <remarks>
        /// <para>Returns a printable &quot;extra string&quot;. This is the component of the string</para>
        /// <para>returned</para>
        /// <para>by vpx_codec_version_str() following the three digit version number.</para>
        /// </remarks>
        public static string VpxCodecVersionExtraStr()
        {
            var ___ret = __Internal.VpxCodecVersionExtraStr();
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Return the build configuration</summary>
        /// <remarks>
        /// <para>Returns a printable string containing an encoded version of the build</para>
        /// <para>configuration. This may be useful to vpx support.</para>
        /// </remarks>
        public static string VpxCodecBuildConfig()
        {
            var ___ret = __Internal.VpxCodecBuildConfig();
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Return the name for a given interface</summary>
        /// <param name="iface">Interface pointer</param>
        /// <remarks>Returns a human readable string for name of the given codec interface.</remarks>
        public static string VpxCodecIfaceName(global::Vpx.VpxCodecIface iface)
        {
            var __arg0 = iface is null ? __IntPtr.Zero : iface.__Instance;
            var ___ret = __Internal.VpxCodecIfaceName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Convert error number to printable string</summary>
        /// <param name="err">Error number.</param>
        /// <remarks>
        /// <para>Returns a human readable string for the last error returned by the</para>
        /// <para>algorithm. The returned error will be one line and will not contain</para>
        /// <para>any newline characters.</para>
        /// </remarks>
        public static string VpxCodecErrToString(global::Vpx.VpxCodecErrT err)
        {
            var ___ret = __Internal.VpxCodecErrToString(err);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Retrieve error synopsis for codec context</summary>
        /// <param name="ctx">Pointer to this instance's context.</param>
        /// <remarks>
        /// <para>Returns a human readable string for the last error returned by the</para>
        /// <para>algorithm. The returned error will be one line and will not contain</para>
        /// <para>any newline characters.</para>
        /// </remarks>
        public static string VpxCodecError(global::Vpx.VpxCodecCtx ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ___ret = __Internal.VpxCodecError(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Retrieve detailed error information for codec context</summary>
        /// <param name="ctx">Pointer to this instance's context.</param>
        /// <remarks>
        /// <para>Returns a human readable string providing detailed information about</para>
        /// <para>the last error. The returned string is only valid until the next</para>
        /// <para>vpx_codec_* function call (except vpx_codec_error and</para>
        /// <para>vpx_codec_error_detail) on the codec context.</para>
        /// <para>No detailed information is available.</para>
        /// </remarks>
        public static string VpxCodecErrorDetail(global::Vpx.VpxCodecCtx ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ___ret = __Internal.VpxCodecErrorDetail(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ___ret);
        }

        /// <summary>Destroy a codec instance</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <remarks>
        /// <para>Destroys a codec context, freeing any associated memory buffers.</para>
        /// <para>The codec instance has been destroyed.</para>
        /// <para>ctx is a null pointer.</para>
        /// <para>Codec context not initialized.</para>
        /// </remarks>
        public static global::Vpx.VpxCodecErrT VpxCodecDestroy(global::Vpx.VpxCodecCtx ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ___ret = __Internal.VpxCodecDestroy(__arg0);
            return ___ret;
        }

        /// <summary>Get the capabilities of an algorithm.</summary>
        /// <param name="iface">Pointer to the algorithm interface</param>
        /// <remarks>Retrieves the capabilities bitfield from the algorithm's interface.</remarks>
        public static int VpxCodecGetCaps(global::Vpx.VpxCodecIface iface)
        {
            var __arg0 = iface is null ? __IntPtr.Zero : iface.__Instance;
            var ___ret = __Internal.VpxCodecGetCaps(__arg0);
            return ___ret;
        }

        /// <summary>Control algorithm</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="ctrl_id">Algorithm specific control identifier</param>
        /// <remarks>
        /// <para>This function is used to exchange algorithm specific data with the codec</para>
        /// <para>instance. This can be used to implement features specific to a particular</para>
        /// <para>algorithm.</para>
        /// <para>This wrapper function dispatches the request to the helper function</para>
        /// <para>associated with the given ctrl_id. It tries to call this function</para>
        /// <para>transparently, but will return #VPX_CODEC_ERROR if the request could not</para>
        /// <para>be dispatched.</para>
        /// <para>Note that this function should not be used directly. Call the</para>
        /// <para>#vpx_codec_control wrapper macro instead.</para>
        /// <para>The control request was processed.</para>
        /// <para>The control request was not processed.</para>
        /// <para>The data was not valid.</para>
        /// </remarks>
        public static global::Vpx.VpxCodecErrT VpxCodecControl(global::Vpx.VpxCodecCtx ctx, int ctrl_id)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ___ret = __Internal.VpxCodecControl(__arg0, ctrl_id);
            return ___ret;
        }
    }

    /// <summary>List of supported image formats</summary>
    public enum VpxImgFmt
    {
        VPX_IMG_FMT_NONE = 0,
        VPX_IMG_FMT_YV12 = 769,
        VPX_IMG_FMT_I420 = 258,
        VPX_IMG_FMT_I422 = 261,
        VPX_IMG_FMT_I444 = 262,
        VPX_IMG_FMT_I440 = 263,
        VPX_IMG_FMT_NV12 = 265,
        VPX_IMG_FMT_I42016 = 2306,
        VPX_IMG_FMT_I42216 = 2309,
        VPX_IMG_FMT_I44416 = 2310,
        VPX_IMG_FMT_I44016 = 2311
    }

    /// <summary>List of supported color spaces</summary>
    public enum VpxColorSpace
    {
        /// <summary>Unknown</summary>
        VPX_CS_UNKNOWN = 0,
        /// <summary>BT.601</summary>
        VPX_CS_BT_601 = 1,
        /// <summary>BT.709</summary>
        VPX_CS_BT_709 = 2,
        /// <summary>SMPTE.170</summary>
        VPX_CS_SMPTE_170 = 3,
        /// <summary>SMPTE.240</summary>
        VPX_CS_SMPTE_240 = 4,
        /// <summary>BT.2020</summary>
        VPX_CS_BT_2020 = 5,
        /// <summary>Reserved</summary>
        VPX_CS_RESERVED = 6,
        /// <summary>sRGB</summary>
        VPX_CS_SRGB = 7
    }

    /// <summary>List of supported color range</summary>
    public enum VpxColorRange
    {
        /// <summary>Y [16..235], UV [16..240]</summary>
        VPX_CR_STUDIO_RANGE = 0,
        /// <summary>YUV/RGB [0..255]</summary>
        VPX_CR_FULL_RANGE = 1
    }

    /// <summary>List of supported image formats</summary>
    /// <summary>List of supported color spaces</summary>
    /// <summary>List of supported color range</summary>
    /// <summary>Image Descriptor</summary>
    /// <summary>Representation of a rectangle on a surface</summary>
    /// <summary>Image Descriptor</summary>
    public unsafe partial class VpxImage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 136)]
        public partial struct __Internal
        {
            internal global::Vpx.VpxImgFmt fmt;
            internal global::Vpx.VpxColorSpace cs;
            internal global::Vpx.VpxColorRange range;
            internal uint w;
            internal uint h;
            internal uint bit_depth;
            internal uint d_w;
            internal uint d_h;
            internal uint r_w;
            internal uint r_h;
            internal uint x_chroma_shift;
            internal uint y_chroma_shift;
            internal __IntPtr planes;
            internal fixed int stride[4];
            internal int bps;
            internal __IntPtr user_priv;
            internal __IntPtr img_data;
            internal int img_data_owner;
            internal int self_allocd;
            internal __IntPtr fb_priv;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_image@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_img_alloc", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr VpxImgAlloc(__IntPtr img, global::Vpx.VpxImgFmt fmt, uint d_w, uint d_h, uint align);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_img_wrap", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr VpxImgWrap(__IntPtr img, global::Vpx.VpxImgFmt fmt, uint d_w, uint d_h, uint stride_align, byte* img_data);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_img_set_rect", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int VpxImgSetRect(__IntPtr img, uint x, uint y, uint w, uint h);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_img_flip", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void VpxImgFlip(__IntPtr img);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_img_free", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void VpxImgFree(__IntPtr img);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxImage> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxImage>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxImage managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxImage managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxImage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxImage(native.ToPointer(), skipVTables);
        }

        internal static VpxImage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxImage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxImage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxImage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxImage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxImage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxImage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxImage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxImage(global::Vpx.VpxImage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxImage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxImage.__Internal*) __Instance) = *((global::Vpx.VpxImage.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Open a descriptor, allocating storage for the underlying image</summary>
        /// <param name="img">
        /// <para>Pointer to storage for descriptor. If this parameter</para>
        /// <para>is NULL, the storage for the descriptor will be</para>
        /// <para>allocated on the heap.</para>
        /// </param>
        /// <param name="fmt">Format for the image</param>
        /// <param name="d_w">Width of the image</param>
        /// <param name="d_h">Height of the image</param>
        /// <param name="align">
        /// <para>Alignment, in bytes, of the image buffer and</para>
        /// <para>each row in the image(stride).</para>
        /// </param>
        /// <returns>
        /// <para>Returns a pointer to the initialized image descriptor. If the img</para>
        /// <para>parameter is non-null, the value of the img parameter will be</para>
        /// <para>returned.</para>
        /// </returns>
        /// <remarks>
        /// <para>Returns a descriptor for storing an image of the given format. The</para>
        /// <para>storage for the descriptor is allocated on the heap.</para>
        /// </remarks>
        public static global::Vpx.VpxImage VpxImgAlloc(global::Vpx.VpxImage img, global::Vpx.VpxImgFmt fmt, uint d_w, uint d_h, uint align)
        {
            var __arg0 = img is null ? __IntPtr.Zero : img.__Instance;
            var ___ret = __Internal.VpxImgAlloc(__arg0, fmt, d_w, d_h, align);
            var __result0 = global::Vpx.VpxImage.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Open a descriptor, using existing storage for the underlying image</summary>
        /// <param name="img">
        /// <para>Pointer to storage for descriptor. If this</para>
        /// <para>parameter is NULL, the storage for the descriptor</para>
        /// <para>will be allocated on the heap.</para>
        /// </param>
        /// <param name="fmt">Format for the image</param>
        /// <param name="d_w">Width of the image</param>
        /// <param name="d_h">Height of the image</param>
        /// <param name="stride_align">Alignment, in bytes, of each row in the image.</param>
        /// <param name="img_data">Storage to use for the image</param>
        /// <returns>
        /// <para>Returns a pointer to the initialized image descriptor. If the img</para>
        /// <para>parameter is non-null, the value of the img parameter will be</para>
        /// <para>returned.</para>
        /// </returns>
        /// <remarks>
        /// <para>Returns a descriptor for storing an image of the given format. The</para>
        /// <para>storage for descriptor has been allocated elsewhere, and a descriptor is</para>
        /// <para>desired to &quot;wrap&quot; that storage.</para>
        /// </remarks>
        public static global::Vpx.VpxImage VpxImgWrap(global::Vpx.VpxImage img, global::Vpx.VpxImgFmt fmt, uint d_w, uint d_h, uint stride_align, byte* img_data)
        {
            var __arg0 = img is null ? __IntPtr.Zero : img.__Instance;
            var ___ret = __Internal.VpxImgWrap(__arg0, fmt, d_w, d_h, stride_align, img_data);
            var __result0 = global::Vpx.VpxImage.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Set the rectangle identifying the displayed portion of the image</summary>
        /// <param name="img">Image descriptor</param>
        /// <param name="x">leftmost column</param>
        /// <param name="y">topmost row</param>
        /// <param name="w">width</param>
        /// <param name="h">height</param>
        /// <returns>0 if the requested rectangle is valid, nonzero (-1) otherwise.</returns>
        /// <remarks>
        /// <para>Updates the displayed rectangle (aka viewport) on the image surface to</para>
        /// <para>match the specified coordinates and size. Specifically, sets img-&gt;d_w,</para>
        /// <para>img-&gt;d_h, and elements of the img-&gt;planes[] array.</para>
        /// </remarks>
        public static int VpxImgSetRect(global::Vpx.VpxImage img, uint x, uint y, uint w, uint h)
        {
            var __arg0 = img is null ? __IntPtr.Zero : img.__Instance;
            var ___ret = __Internal.VpxImgSetRect(__arg0, x, y, w, h);
            return ___ret;
        }

        /// <summary>Flip the image vertically (top for bottom)</summary>
        /// <param name="img">Image descriptor</param>
        /// <remarks>
        /// <para>Adjusts the image descriptor's pointers and strides to make the image</para>
        /// <para>be referenced upside-down.</para>
        /// </remarks>
        public static void VpxImgFlip(global::Vpx.VpxImage img)
        {
            var __arg0 = img is null ? __IntPtr.Zero : img.__Instance;
            __Internal.VpxImgFlip(__arg0);
        }

        /// <summary>Close an image descriptor</summary>
        /// <param name="img">Image descriptor</param>
        /// <remarks>Frees all allocated storage associated with an image descriptor.</remarks>
        public static void VpxImgFree(global::Vpx.VpxImage img)
        {
            var __arg0 = img is null ? __IntPtr.Zero : img.__Instance;
            __Internal.VpxImgFree(__arg0);
        }

        /// <summary>Image Format</summary>
        public global::Vpx.VpxImgFmt Fmt
        {
            get
            {
                return ((__Internal*)__Instance)->fmt;
            }

            set
            {
                ((__Internal*)__Instance)->fmt = value;
            }
        }

        /// <summary>Color Space</summary>
        public global::Vpx.VpxColorSpace Cs
        {
            get
            {
                return ((__Internal*)__Instance)->cs;
            }

            set
            {
                ((__Internal*)__Instance)->cs = value;
            }
        }

        /// <summary>Color Range</summary>
        public global::Vpx.VpxColorRange Range
        {
            get
            {
                return ((__Internal*)__Instance)->range;
            }

            set
            {
                ((__Internal*)__Instance)->range = value;
            }
        }

        /// <summary>Stored image width</summary>
        public uint W
        {
            get
            {
                return ((__Internal*)__Instance)->w;
            }

            set
            {
                ((__Internal*)__Instance)->w = value;
            }
        }

        /// <summary>Stored image height</summary>
        public uint H
        {
            get
            {
                return ((__Internal*)__Instance)->h;
            }

            set
            {
                ((__Internal*)__Instance)->h = value;
            }
        }

        /// <summary>Stored image bit-depth</summary>
        public uint BitDepth
        {
            get
            {
                return ((__Internal*)__Instance)->bit_depth;
            }

            set
            {
                ((__Internal*)__Instance)->bit_depth = value;
            }
        }

        /// <summary>Displayed image width</summary>
        public uint DW
        {
            get
            {
                return ((__Internal*)__Instance)->d_w;
            }

            set
            {
                ((__Internal*)__Instance)->d_w = value;
            }
        }

        /// <summary>Displayed image height</summary>
        public uint DH
        {
            get
            {
                return ((__Internal*)__Instance)->d_h;
            }

            set
            {
                ((__Internal*)__Instance)->d_h = value;
            }
        }

        /// <summary>Intended rendering image width</summary>
        public uint RW
        {
            get
            {
                return ((__Internal*)__Instance)->r_w;
            }

            set
            {
                ((__Internal*)__Instance)->r_w = value;
            }
        }

        /// <summary>Intended rendering image height</summary>
        public uint RH
        {
            get
            {
                return ((__Internal*)__Instance)->r_h;
            }

            set
            {
                ((__Internal*)__Instance)->r_h = value;
            }
        }

        /// <summary>subsampling order, X</summary>
        public uint XChromaShift
        {
            get
            {
                return ((__Internal*)__Instance)->x_chroma_shift;
            }

            set
            {
                ((__Internal*)__Instance)->x_chroma_shift = value;
            }
        }

        /// <summary>subsampling order, Y</summary>
        public uint YChromaShift
        {
            get
            {
                return ((__Internal*)__Instance)->y_chroma_shift;
            }

            set
            {
                ((__Internal*)__Instance)->y_chroma_shift = value;
            }
        }

        /// <summary>pointer to the top left pixel for each plane</summary>
        private byte*[] __planes;

        private bool __planesInitialised;
        /// <summary>pointer to the top left pixel for each plane</summary>
        public byte*[] Planes
        {
            get
            {
                if (!__planesInitialised)
                {
                    __planes = null;
                    __planesInitialised = true;
                }
                return __planes;
            }

            set
            {
                __planes = value;
                if (!__planesInitialised)
                {
                    __planesInitialised = true;
                }
            }
        }

        /// <summary>stride between rows for each plane</summary>
        public int[] Stride
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->stride, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->stride[i] = value[i];
                }
            }
        }

        /// <summary>bits per sample (for packed formats)</summary>
        public int Bps
        {
            get
            {
                return ((__Internal*)__Instance)->bps;
            }

            set
            {
                ((__Internal*)__Instance)->bps = value;
            }
        }

        /// <summary>
        /// <para>The following member may be set by the application to associate</para>
        /// <para>data with this image.</para>
        /// </summary>
        public __IntPtr UserPriv
        {
            get
            {
                return ((__Internal*)__Instance)->user_priv;
            }

            set
            {
                ((__Internal*)__Instance)->user_priv = (__IntPtr) value;
            }
        }

        /// <summary>private</summary>
        public byte* ImgData
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->img_data;
            }

            set
            {
                ((__Internal*)__Instance)->img_data = (__IntPtr) value;
            }
        }

        /// <summary>private</summary>
        public int ImgDataOwner
        {
            get
            {
                return ((__Internal*)__Instance)->img_data_owner;
            }

            set
            {
                ((__Internal*)__Instance)->img_data_owner = value;
            }
        }

        /// <summary>private</summary>
        public int SelfAllocd
        {
            get
            {
                return ((__Internal*)__Instance)->self_allocd;
            }

            set
            {
                ((__Internal*)__Instance)->self_allocd = value;
            }
        }

        /// <summary>Frame buffer data associated with the image.</summary>
        public __IntPtr FbPriv
        {
            get
            {
                return ((__Internal*)__Instance)->fb_priv;
            }

            set
            {
                ((__Internal*)__Instance)->fb_priv = (__IntPtr) value;
            }
        }
    }

    /// <summary>Representation of a rectangle on a surface</summary>
    public unsafe partial class VpxImageRect : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal uint x;
            internal uint y;
            internal uint w;
            internal uint h;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_image_rect@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxImageRect> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxImageRect>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxImageRect managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxImageRect managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxImageRect __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxImageRect(native.ToPointer(), skipVTables);
        }

        internal static VpxImageRect __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxImageRect)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxImageRect __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxImageRect(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxImageRect(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxImageRect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxImageRect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxImageRect.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxImageRect(global::Vpx.VpxImageRect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxImageRect.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxImageRect.__Internal*) __Instance) = *((global::Vpx.VpxImageRect.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>leftmost column</summary>
        public uint X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        /// <summary>topmost row</summary>
        public uint Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        /// <summary>width</summary>
        public uint W
        {
            get
            {
                return ((__Internal*)__Instance)->w;
            }

            set
            {
                ((__Internal*)__Instance)->w = value;
            }
        }

        /// <summary>height</summary>
        public uint H
        {
            get
            {
                return ((__Internal*)__Instance)->h;
            }

            set
            {
                ((__Internal*)__Instance)->h = value;
            }
        }
    }

    /// <summary>Stream properties</summary>
    /// <remarks>
    /// <para>This structure is used to query or set properties of the decoded</para>
    /// <para>stream. Algorithms may extend this structure with data specific</para>
    /// <para>to their bitstream by setting the sz member appropriately.</para>
    /// </remarks>
    /// <summary>Initialization Configurations</summary>
    /// <remarks>
    /// <para>This structure is used to pass init time configuration options to the</para>
    /// <para>decoder.</para>
    /// </remarks>
    /// <summary>put frame callback prototype</summary>
    /// <remarks>
    /// <para>This callback is invoked by the decoder to notify the application of</para>
    /// <para>the availability of decoded image data.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void VpxCodecPutFrameCbFnT(__IntPtr user_priv, __IntPtr img);

    /// <summary>put slice callback prototype</summary>
    /// <remarks>
    /// <para>This callback is invoked by the decoder to notify the application of</para>
    /// <para>the availability of partially decoded image data.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void VpxCodecPutSliceCbFnT(__IntPtr user_priv, __IntPtr img, __IntPtr valid, __IntPtr update);

    /// <summary>Stream properties</summary>
    /// <remarks>
    /// <para>This structure is used to query or set properties of the decoded</para>
    /// <para>stream. Algorithms may extend this structure with data specific</para>
    /// <para>to their bitstream by setting the sz member appropriately.</para>
    /// </remarks>
    public unsafe partial class VpxCodecStreamInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal uint sz;
            internal uint w;
            internal uint h;
            internal uint is_kf;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_codec_stream_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecStreamInfo> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecStreamInfo>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxCodecStreamInfo managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxCodecStreamInfo managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxCodecStreamInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxCodecStreamInfo(native.ToPointer(), skipVTables);
        }

        internal static VpxCodecStreamInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxCodecStreamInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxCodecStreamInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxCodecStreamInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxCodecStreamInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxCodecStreamInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxCodecStreamInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxCodecStreamInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxCodecStreamInfo(global::Vpx.VpxCodecStreamInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxCodecStreamInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxCodecStreamInfo.__Internal*) __Instance) = *((global::Vpx.VpxCodecStreamInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Size of this structure</summary>
        public uint Sz
        {
            get
            {
                return ((__Internal*)__Instance)->sz;
            }

            set
            {
                ((__Internal*)__Instance)->sz = value;
            }
        }

        /// <summary>Width (or 0 for unknown/default)</summary>
        public uint W
        {
            get
            {
                return ((__Internal*)__Instance)->w;
            }

            set
            {
                ((__Internal*)__Instance)->w = value;
            }
        }

        /// <summary>Height (or 0 for unknown/default)</summary>
        public uint H
        {
            get
            {
                return ((__Internal*)__Instance)->h;
            }

            set
            {
                ((__Internal*)__Instance)->h = value;
            }
        }

        /// <summary>Current frame is a keyframe</summary>
        public uint IsKf
        {
            get
            {
                return ((__Internal*)__Instance)->is_kf;
            }

            set
            {
                ((__Internal*)__Instance)->is_kf = value;
            }
        }
    }

    /// <summary>Initialization Configurations</summary>
    /// <remarks>
    /// <para>This structure is used to pass init time configuration options to the</para>
    /// <para>decoder.</para>
    /// </remarks>
    public unsafe partial class VpxCodecDecCfg : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal uint threads;
            internal uint w;
            internal uint h;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_codec_dec_cfg@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecDecCfg> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecDecCfg>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxCodecDecCfg managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxCodecDecCfg managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxCodecDecCfg __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxCodecDecCfg(native.ToPointer(), skipVTables);
        }

        internal static VpxCodecDecCfg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxCodecDecCfg)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxCodecDecCfg __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxCodecDecCfg(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxCodecDecCfg(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxCodecDecCfg(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxCodecDecCfg()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxCodecDecCfg.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxCodecDecCfg(global::Vpx.VpxCodecDecCfg _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxCodecDecCfg.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxCodecDecCfg.__Internal*) __Instance) = *((global::Vpx.VpxCodecDecCfg.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Maximum number of threads to use, default 1</summary>
        public uint Threads
        {
            get
            {
                return ((__Internal*)__Instance)->threads;
            }

            set
            {
                ((__Internal*)__Instance)->threads = value;
            }
        }

        /// <summary>Width</summary>
        public uint W
        {
            get
            {
                return ((__Internal*)__Instance)->w;
            }

            set
            {
                ((__Internal*)__Instance)->w = value;
            }
        }

        /// <summary>Height</summary>
        public uint H
        {
            get
            {
                return ((__Internal*)__Instance)->h;
            }

            set
            {
                ((__Internal*)__Instance)->h = value;
            }
        }
    }

    public unsafe partial class vpx_decoder
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_dec_init_ver", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecDecInitVer(__IntPtr ctx, __IntPtr iface, __IntPtr cfg, int flags, int ver);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_peek_stream_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecPeekStreamInfo(__IntPtr iface, byte* data, uint data_sz, __IntPtr si);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_get_stream_info", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecGetStreamInfo(__IntPtr ctx, __IntPtr si);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_decode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecDecode(__IntPtr ctx, byte* data, uint data_sz, __IntPtr user_priv, int deadline);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_get_frame", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr VpxCodecGetFrame(__IntPtr ctx, __IntPtr* iter);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_register_put_frame_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecRegisterPutFrameCb(__IntPtr ctx, __IntPtr cb, __IntPtr user_priv);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_register_put_slice_cb", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecRegisterPutSliceCb(__IntPtr ctx, __IntPtr cb, __IntPtr user_priv);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_set_frame_buffer_functions", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecSetFrameBufferFunctions(__IntPtr ctx, __IntPtr cb_get, __IntPtr cb_release, __IntPtr cb_priv);
        }

        /// <summary>Initialize a decoder instance</summary>
        /// <param name="ctx">Pointer to this instance's context.</param>
        /// <param name="iface">Pointer to the algorithm interface to use.</param>
        /// <param name="cfg">Configuration to use, if known. May be NULL.</param>
        /// <param name="flags">Bitfield of VPX_CODEC_USE_* flags</param>
        /// <param name="ver">
        /// <para>ABI version number. Must be set to</para>
        /// <para>VPX_DECODER_ABI_VERSION</para>
        /// </param>
        /// <remarks>
        /// <para>Initializes a decoder context using the given interface. Applications</para>
        /// <para>should call the vpx_codec_dec_init convenience macro instead of this</para>
        /// <para>function directly, to ensure that the ABI version number parameter</para>
        /// <para>is properly initialized.</para>
        /// <para>If the library was configured with --disable-multithread, this call</para>
        /// <para>is not thread safe and should be guarded with a lock if being used</para>
        /// <para>in a multithreaded context.</para>
        /// <para>The decoder algorithm has been initialized.</para>
        /// <para>Memory allocation failed.</para>
        /// </remarks>
        public static global::Vpx.VpxCodecErrT VpxCodecDecInitVer(global::Vpx.VpxCodecCtx ctx, global::Vpx.VpxCodecIface iface, global::Vpx.VpxCodecDecCfg cfg, int flags, int ver)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var __arg1 = iface is null ? __IntPtr.Zero : iface.__Instance;
            var __arg2 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            var ___ret = __Internal.VpxCodecDecInitVer(__arg0, __arg1, __arg2, flags, ver);
            return ___ret;
        }

        /// <summary>Parse stream info from a buffer</summary>
        /// <param name="iface">Pointer to the algorithm interface</param>
        /// <param name="data">Pointer to a block of data to parse</param>
        /// <param name="data_sz">Size of the data buffer</param>
        /// <param name="si">
        /// <para>Pointer to stream info to update. The size member</para>
        /// <para>be properly initialized, butbe</para>
        /// <para>clobbered by the algorithm. This parameterbe NULL.</para>
        /// </param>
        /// <remarks>
        /// <para>Performs high level parsing of the bitstream. Construction of a decoder</para>
        /// <para>context is not necessary. Can be used to determine if the bitstream is</para>
        /// <para>of the proper format, and to extract information from the stream.</para>
        /// <para>Bitstream is parsable and stream information updated</para>
        /// </remarks>
        public static global::Vpx.VpxCodecErrT VpxCodecPeekStreamInfo(global::Vpx.VpxCodecIface iface, byte* data, uint data_sz, global::Vpx.VpxCodecStreamInfo si)
        {
            var __arg0 = iface is null ? __IntPtr.Zero : iface.__Instance;
            var __arg3 = si is null ? __IntPtr.Zero : si.__Instance;
            var ___ret = __Internal.VpxCodecPeekStreamInfo(__arg0, data, data_sz, __arg3);
            return ___ret;
        }

        /// <summary>Return information about the current stream.</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="si">
        /// <para>Pointer to stream info to update. The size member</para>
        /// <para>be properly initialized, butbe</para>
        /// <para>clobbered by the algorithm. This parameterbe NULL.</para>
        /// </param>
        /// <remarks>
        /// <para>Returns information about the stream that has been parsed during decoding.</para>
        /// <para>Bitstream is parsable and stream information updated</para>
        /// </remarks>
        public static global::Vpx.VpxCodecErrT VpxCodecGetStreamInfo(global::Vpx.VpxCodecCtx ctx, global::Vpx.VpxCodecStreamInfo si)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var __arg1 = si is null ? __IntPtr.Zero : si.__Instance;
            var ___ret = __Internal.VpxCodecGetStreamInfo(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Decode data</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="data">
        /// <para>Pointer to this block of new coded data. If</para>
        /// <para>NULL, the put_frame callback is invoked for</para>
        /// <para>the previously decoded frame.</para>
        /// </param>
        /// <param name="data_sz">Size of the coded data, in bytes.</param>
        /// <param name="user_priv">
        /// <para>Application specific data to associate with</para>
        /// <para>this frame.</para>
        /// </param>
        /// <param name="deadline">
        /// <para>Soft deadline the decoder should attempt to meet,</para>
        /// <para>in us. Set to zero for unlimited.</para>
        /// </param>
        /// <returns>
        /// <para>Returns #VPX_CODEC_OK if the coded data was processed completely</para>
        /// <para>and future pictures can be decoded without error. Otherwise,</para>
        /// <para>see the descriptions of the other error codes in ::vpx_codec_err_t</para>
        /// <para>for recoverability capabilities.</para>
        /// </returns>
        /// <remarks>
        /// <para>Processes a buffer of coded data. If the processing results in a new</para>
        /// <para>decoded frame becoming available, put_slice and put_frame callbacks may be</para>
        /// <para>invoked, as appropriate. Encoded databe passed in DTS (decode</para>
        /// <para>time stamp) order. Frames produced will always be in PTS (presentation</para>
        /// <para>time stamp) order.</para>
        /// <para>If the decoder is configured with VPX_CODEC_USE_INPUT_FRAGMENTS enabled,</para>
        /// <para>data and data_sz can contain a fragment of the encoded frame. Fragment</para>
        /// <para>#n must contain at least partition#n, but can also contain subsequent</para>
        /// <para>partitions (#n+1 -#n+i), and if so, fragments#n+1, ..,#n+i must</para>
        /// <para>be empty. When no more data is available, this function should be called</para>
        /// <para>with NULL as data and 0 as data_sz. The memory passed to this function</para>
        /// <para>must be available until the frame has been decoded.</para>
        /// </remarks>
        public static global::Vpx.VpxCodecErrT VpxCodecDecode(global::Vpx.VpxCodecCtx ctx, byte* data, uint data_sz, __IntPtr user_priv, int deadline)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ___ret = __Internal.VpxCodecDecode(__arg0, data, data_sz, user_priv, deadline);
            return ___ret;
        }

        /// <summary>Decoded frames iterator</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="iter">Iterator storage, initialized to NULL</param>
        /// <returns>
        /// <para>Returns a pointer to an image, if one is ready for display. Frames</para>
        /// <para>produced will always be in PTS (presentation time stamp) order.</para>
        /// </returns>
        /// <remarks>
        /// <para>Iterates over a list of the frames available for display. The iterator</para>
        /// <para>storage should be initialized to NULL to start the iteration. Iteration is</para>
        /// <para>complete when this function returns NULL.</para>
        /// <para>The list of available frames becomes valid upon completion of the</para>
        /// <para>vpx_codec_decode call, and remains valid until the next call to</para>
        /// <para>vpx_codec_decode.</para>
        /// </remarks>
        public static global::Vpx.VpxImage VpxCodecGetFrame(global::Vpx.VpxCodecCtx ctx, __IntPtr* iter)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ___ret = __Internal.VpxCodecGetFrame(__arg0, iter);
            var __result0 = global::Vpx.VpxImage.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Register for notification of frame completion.</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="cb">Pointer to the callback function</param>
        /// <param name="user_priv">User's private data</param>
        /// <remarks>
        /// <para>Registers a given function to be called when a decoded frame is</para>
        /// <para>available.</para>
        /// <para>Callback successfully registered.</para>
        /// <para>Decoder context not initialized.</para>
        /// <para>Algorithm not capable of posting frame completion.</para>
        /// </remarks>
        public static global::Vpx.VpxCodecErrT VpxCodecRegisterPutFrameCb(global::Vpx.VpxCodecCtx ctx, global::Vpx.VpxCodecPutFrameCbFnT cb, __IntPtr user_priv)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            var ___ret = __Internal.VpxCodecRegisterPutFrameCb(__arg0, __arg1, user_priv);
            return ___ret;
        }

        /// <summary>Register for notification of slice completion.</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="cb">Pointer to the callback function</param>
        /// <param name="user_priv">User's private data</param>
        /// <remarks>
        /// <para>Registers a given function to be called when a decoded slice is</para>
        /// <para>available.</para>
        /// <para>Callback successfully registered.</para>
        /// <para>Decoder context not initialized.</para>
        /// <para>Algorithm not capable of posting slice completion.</para>
        /// </remarks>
        public static global::Vpx.VpxCodecErrT VpxCodecRegisterPutSliceCb(global::Vpx.VpxCodecCtx ctx, global::Vpx.VpxCodecPutSliceCbFnT cb, __IntPtr user_priv)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var __arg1 = cb == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb);
            var ___ret = __Internal.VpxCodecRegisterPutSliceCb(__arg0, __arg1, user_priv);
            return ___ret;
        }

        /// <summary>Pass in external frame buffers for the decoder to use.</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="cb_get">Pointer to the get callback function</param>
        /// <param name="cb_release">Pointer to the release callback function</param>
        /// <param name="cb_priv">Callback's private data</param>
        /// <remarks>
        /// <para>Registers functions to be called when libvpx needs a frame buffer</para>
        /// <para>to decode the current frame and a function to be called when libvpx does</para>
        /// <para>not internally reference the frame buffer. This set function must</para>
        /// <para>be called before the first call to decode or libvpx will assume the</para>
        /// <para>default behavior of allocating frame buffers internally.</para>
        /// <para>External frame buffers will be used by libvpx.</para>
        /// <para>One or more of the callbacks were NULL.</para>
        /// <para>Decoder context not initialized.</para>
        /// <para>Algorithm not capable of using external frame buffers.</para>
        /// <para>When decoding VP9, the application may be required to pass in at least</para>
        /// <para>#VP9_MAXIMUM_REF_BUFFERS + #VPX_MAXIMUM_WORK_BUFFERS external frame</para>
        /// <para>buffers.</para>
        /// </remarks>
        public static global::Vpx.VpxCodecErrT VpxCodecSetFrameBufferFunctions(global::Vpx.VpxCodecCtx ctx, global::Vpx.VpxGetFrameBufferCbFnT cb_get, global::Vpx.VpxReleaseFrameBufferCbFnT cb_release, __IntPtr cb_priv)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var __arg1 = cb_get == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb_get);
            var __arg2 = cb_release == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(cb_release);
            var ___ret = __Internal.VpxCodecSetFrameBufferFunctions(__arg0, __arg1, __arg2, cb_priv);
            return ___ret;
        }
    }

    /// <summary>External frame buffer</summary>
    /// <remarks>This structure holds allocated frame buffers used by the decoder.</remarks>
    /// <summary>get frame buffer callback prototype</summary>
    /// <param name="priv">Callback's private data</param>
    /// <param name="min_size">Size in bytes needed by the buffer</param>
    /// <param name="fb">Pointer to vpx_codec_frame_buffer_t</param>
    /// <remarks>
    /// <para>This callback is invoked by the decoder to retrieve data for the frame</para>
    /// <para>buffer in order for the decode call to complete. The callback must</para>
    /// <para>allocate at least min_size in bytes and assign it to fb-&gt;data. The callback</para>
    /// <para>must zero out all the data allocated. Then the callback must set fb-&gt;size</para>
    /// <para>to the allocated size. The application does not need to align the allocated</para>
    /// <para>data. The callback is triggered when the decoder needs a frame buffer to</para>
    /// <para>decode a compressed image into. This function may be called more than once</para>
    /// <para>for every call to vpx_codec_decode. The application may set fb-&gt;priv to</para>
    /// <para>some data which will be passed back in the vpx_image_t and the release</para>
    /// <para>function call. |fb| is guaranteed to not be NULL. On success the callback</para>
    /// <para>must return 0. Any failure the callback must return a value less than 0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int VpxGetFrameBufferCbFnT(__IntPtr priv, ulong min_size, __IntPtr fb);

    /// <summary>release frame buffer callback prototype</summary>
    /// <param name="priv">Callback's private data</param>
    /// <param name="fb">Pointer to vpx_codec_frame_buffer_t</param>
    /// <remarks>
    /// <para>This callback is invoked by the decoder when the frame buffer is not</para>
    /// <para>referenced by any other buffers. |fb| is guaranteed to not be NULL. On</para>
    /// <para>success the callback must return 0. Any failure the callback must return</para>
    /// <para>a value less than 0.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int VpxReleaseFrameBufferCbFnT(__IntPtr priv, __IntPtr fb);

    /// <summary>External frame buffer</summary>
    /// <remarks>This structure holds allocated frame buffers used by the decoder.</remarks>
    public unsafe partial class VpxCodecFrameBuffer : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal __IntPtr data;
            internal ulong size;
            internal __IntPtr priv;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_codec_frame_buffer@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecFrameBuffer> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecFrameBuffer>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxCodecFrameBuffer managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxCodecFrameBuffer managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxCodecFrameBuffer __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxCodecFrameBuffer(native.ToPointer(), skipVTables);
        }

        internal static VpxCodecFrameBuffer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxCodecFrameBuffer)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxCodecFrameBuffer __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxCodecFrameBuffer(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxCodecFrameBuffer(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxCodecFrameBuffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxCodecFrameBuffer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxCodecFrameBuffer.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxCodecFrameBuffer(global::Vpx.VpxCodecFrameBuffer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxCodecFrameBuffer.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxCodecFrameBuffer.__Internal*) __Instance) = *((global::Vpx.VpxCodecFrameBuffer.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Pointer to the data buffer</summary>
        public byte* Data
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->data;
            }

            set
            {
                ((__Internal*)__Instance)->data = (__IntPtr) value;
            }
        }

        /// <summary>Size of data in bytes</summary>
        public ulong Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }

        /// <summary>Frame's private data</summary>
        public __IntPtr Priv
        {
            get
            {
                return ((__Internal*)__Instance)->priv;
            }

            set
            {
                ((__Internal*)__Instance)->priv = (__IntPtr) value;
            }
        }
    }

    /// <summary>Encoder output packet variants</summary>
    /// <remarks>
    /// <para>This enumeration lists the different kinds of data packets that can be</para>
    /// <para>returned by calls to vpx_codec_get_cx_data(). Algorithmsextend this list to provide additional functionality.</para>
    /// </remarks>
    public enum VpxCodecCxPktKind
    {
        /// <summary>Compressed video frame</summary>
        VPX_CODEC_CX_FRAME_PKT = 0,
        /// <summary>Two-pass statistics for this frame</summary>
        VPX_CODEC_STATS_PKT = 1,
        /// <summary>first pass mb statistics for this frame</summary>
        VPX_CODEC_FPMB_STATS_PKT = 2,
        /// <summary>PSNR statistics for this frame</summary>
        VPX_CODEC_PSNR_PKT = 3,
        /// <summary>Algorithm extensions</summary>
        VPX_CODEC_CUSTOM_PKT = 256
    }

    /// <summary>Multi-pass Encoding Pass</summary>
    public enum VpxEncPass
    {
        /// <summary>Single pass mode</summary>
        VPX_RC_ONE_PASS = 0,
        /// <summary>First pass of multi-pass mode</summary>
        VPX_RC_FIRST_PASS = 1,
        /// <summary>Final pass of multi-pass mode</summary>
        VPX_RC_LAST_PASS = 2
    }

    /// <summary>Rate control mode</summary>
    public enum VpxRcMode
    {
        /// <summary>Variable Bit Rate (VBR) mode</summary>
        VPX_VBR = 0,
        /// <summary>Constant Bit Rate (CBR) mode</summary>
        VPX_CBR = 1,
        /// <summary>Constrained Quality (CQ)  mode</summary>
        VPX_CQ = 2,
        /// <summary>Constant Quality (Q) mode</summary>
        VPX_Q = 3
    }

    /// <summary>Keyframe placement mode.</summary>
    /// <remarks>
    /// <para>This enumeration determines whether keyframes are placed automatically by</para>
    /// <para>the encoder or whether this behavior is disabled. Older releases of this</para>
    /// <para>SDK were implemented such that VPX_KF_FIXED meant keyframes were disabled.</para>
    /// <para>This name is confusing for this behavior, so the new symbols to be used</para>
    /// <para>are VPX_KF_AUTO and VPX_KF_DISABLED.</para>
    /// </remarks>
    public enum VpxKfMode
    {
        /// <summary>deprecated, implies VPX_KF_DISABLED</summary>
        VPX_KF_FIXED = 0,
        /// <summary>Encoder determines optimal placement automatically</summary>
        VPX_KF_AUTO = 1,
        /// <summary>Encoder does not place keyframes.</summary>
        VPX_KF_DISABLED = 0
    }

    /// <summary>Generic fixed size buffer structure</summary>
    /// <remarks>This structure is able to hold a reference to any fixed size buffer.</remarks>
    /// <summary>Time Stamp Type</summary>
    /// <remarks>
    /// <para>An integer, which when multiplied by the stream's time base, provides</para>
    /// <para>the absolute time of a sample.</para>
    /// </remarks>
    /// <summary>Compressed Frame Flags</summary>
    /// <remarks>
    /// <para>This type represents a bitfield containing information about a compressed</para>
    /// <para>frame that may be useful to an application. The most significant 16 bits</para>
    /// <para>can be used by an algorithm to provide additional detail, for example to</para>
    /// <para>support frame types that are codec specific (MPEG-1 D-frames for example)</para>
    /// </remarks>
    /// <summary>Error Resilient flags</summary>
    /// <remarks>
    /// <para>These flags define which error resilient features to enable in the</para>
    /// <para>encoder. The flags are specified through the</para>
    /// <para>vpx_codec_enc_cfg::g_error_resilient variable.</para>
    /// </remarks>
    /// <summary>Encoder output packet</summary>
    /// <remarks>
    /// <para>This structure contains the different kinds of output data the encoder</para>
    /// <para>may produce while compressing a frame.</para>
    /// </remarks>
    /// <summary>Encoder return output buffer callback</summary>
    /// <remarks>
    /// <para>This callback function, when registered, returns with packets when each</para>
    /// <para>spatial layer is encoded.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void VpxCodecEncOutputCxPktCbFnT(__IntPtr pkt, __IntPtr user_data);

    /// <summary>Callback function pointer / user data pair storage</summary>
    /// <summary>Rational Number</summary>
    /// <remarks>This structure holds a fractional value.</remarks>
    /// <summary>Multi-pass Encoding Pass</summary>
    /// <summary>Encoded Frame Flags</summary>
    /// <remarks>
    /// <para>This type indicates a bitfield to be passed to vpx_codec_encode(), defining</para>
    /// <para>per-frame boolean values. By convention, bits common to all codecs will be</para>
    /// <para>named VPX_EFLAG_*, and bits specific to an algorithm will be named</para>
    /// <para>/algo/_eflag_*. The lower order 16 bits are reserved for common use.</para>
    /// </remarks>
    /// <summary>Encoder configuration structure</summary>
    /// <remarks>
    /// <para>This structure contains the encoder settings that have common representations</para>
    /// <para>across all codecs. This doesn't imply that all codecs support all features,</para>
    /// <para>however.</para>
    /// </remarks>
    /// <summary>vp9 svc extra configure parameters</summary>
    /// <remarks>This defines max/min quantizers and scale factors for each layer</remarks>
    /// <summary>Generic fixed size buffer structure</summary>
    /// <remarks>This structure is able to hold a reference to any fixed size buffer.</remarks>
    public unsafe partial class VpxFixedBuf : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr buf;
            internal ulong sz;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_fixed_buf@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxFixedBuf> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxFixedBuf>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxFixedBuf managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxFixedBuf managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxFixedBuf __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxFixedBuf(native.ToPointer(), skipVTables);
        }

        internal static VpxFixedBuf __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxFixedBuf)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxFixedBuf __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxFixedBuf(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxFixedBuf(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxFixedBuf(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxFixedBuf()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxFixedBuf.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxFixedBuf(global::Vpx.VpxFixedBuf _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxFixedBuf.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxFixedBuf.__Internal*) __Instance) = *((global::Vpx.VpxFixedBuf.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Pointer to the data</summary>
        public __IntPtr Buf
        {
            get
            {
                return ((__Internal*)__Instance)->buf;
            }

            set
            {
                ((__Internal*)__Instance)->buf = (__IntPtr) value;
            }
        }

        /// <summary>Length of the buffer, in chars</summary>
        public ulong Sz
        {
            get
            {
                return ((__Internal*)__Instance)->sz;
            }

            set
            {
                ((__Internal*)__Instance)->sz = value;
            }
        }
    }

    /// <summary>Encoder output packet</summary>
    /// <remarks>
    /// <para>This structure contains the different kinds of output data the encoder</para>
    /// <para>may produce while compressing a frame.</para>
    /// </remarks>
    public unsafe partial class VpxCodecCxPkt : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 136)]
        public partial struct __Internal
        {
            internal global::Vpx.VpxCodecCxPktKind kind;
            internal global::Vpx.VpxCodecCxPkt.Data.__Internal data;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_codec_cx_pkt@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public unsafe partial struct Data
        {
            [StructLayout(LayoutKind.Explicit, Size = 128)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Vpx.VpxCodecCxPkt.Data.Frame.__Internal frame;

                [FieldOffset(0)]
                internal global::Vpx.VpxFixedBuf.__Internal twopass_stats;

                [FieldOffset(0)]
                internal global::Vpx.VpxFixedBuf.__Internal firstpass_mb_stats;

                [FieldOffset(0)]
                internal global::Vpx.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal psnr;

                [FieldOffset(0)]
                internal global::Vpx.VpxFixedBuf.__Internal raw;

                [FieldOffset(0)]
                internal fixed sbyte pad[124];

                [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0<unnamed-type-data>@vpx_codec_cx_pkt@@QEAA@AEBT01@@Z", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
            }

            public unsafe partial class Frame : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 88)]
                public partial struct __Internal
                {
                    internal __IntPtr buf;
                    internal ulong sz;
                    internal long pts;
                    internal uint duration;
                    internal uint flags;
                    internal int partition_id;
                    internal fixed uint width[5];
                    internal fixed uint height[5];
                    internal fixed byte spatial_layer_encoded[5];

                    [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0<unnamed-type-frame>@<unnamed-type-data>@vpx_codec_cx_pkt@@QEAA@AEBU012@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecCxPkt.Data.Frame> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecCxPkt.Data.Frame>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxCodecCxPkt.Data.Frame managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxCodecCxPkt.Data.Frame managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static Frame __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new Frame(native.ToPointer(), skipVTables);
                }

                internal static Frame __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (Frame)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static Frame __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new Frame(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Frame(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected Frame(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public Frame()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxCodecCxPkt.Data.Frame.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                public Frame(global::Vpx.VpxCodecCxPkt.Data.Frame _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxCodecCxPkt.Data.Frame.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    *((global::Vpx.VpxCodecCxPkt.Data.Frame.__Internal*) __Instance) = *((global::Vpx.VpxCodecCxPkt.Data.Frame.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                /// <summary>compressed data buffer</summary>
                public __IntPtr Buf
                {
                    get
                    {
                        return ((__Internal*)__Instance)->buf;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->buf = (__IntPtr) value;
                    }
                }

                /// <summary>length of compressed data</summary>
                public ulong Sz
                {
                    get
                    {
                        return ((__Internal*)__Instance)->sz;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->sz = value;
                    }
                }

                /// <summary>time stamp to show frame (in timebase units)</summary>
                public long Pts
                {
                    get
                    {
                        return ((__Internal*)__Instance)->pts;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->pts = value;
                    }
                }

                /// <summary>duration to show frame (in timebase units)</summary>
                public uint Duration
                {
                    get
                    {
                        return ((__Internal*)__Instance)->duration;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->duration = value;
                    }
                }

                /// <summary>flags for this frame</summary>
                public uint Flags
                {
                    get
                    {
                        return ((__Internal*)__Instance)->flags;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->flags = value;
                    }
                }

                /// <summary>
                /// <para>the partition id defines the decoding order of the partitions.</para>
                /// <para>Only applicable when &quot;output partition&quot; mode is enabled. First</para>
                /// <para>partition has id 0.</para>
                /// </summary>
                public int PartitionId
                {
                    get
                    {
                        return ((__Internal*)__Instance)->partition_id;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->partition_id = value;
                    }
                }

                /// <summary>frame width</summary>
                public uint[] Width
                {
                    get
                    {
                        return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->width, 5);
                    }

                    set
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 5; i++)
                                ((__Internal*)__Instance)->width[i] = value[i];
                        }
                    }
                }

                /// <summary>frame height</summary>
                public uint[] Height
                {
                    get
                    {
                        return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->height, 5);
                    }

                    set
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 5; i++)
                                ((__Internal*)__Instance)->height[i] = value[i];
                        }
                    }
                }

                /// <summary>
                /// <para>Flag to indicate if spatial layer frame in this packet is</para>
                /// <para>encoded or dropped. VP8 will always be set to 1.</para>
                /// </summary>
                public byte[] SpatialLayerEncoded
                {
                    get
                    {
                        return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->spatial_layer_encoded, 5);
                    }

                    set
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 5; i++)
                                ((__Internal*)__Instance)->spatial_layer_encoded[i] = value[i];
                        }
                    }
                }
            }

            public unsafe partial class VpxPsnrPkt : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 80)]
                public partial struct __Internal
                {
                    internal fixed uint samples[4];
                    internal fixed ulong sse[4];
                    internal fixed double psnr[4];

                    [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_psnr_pkt@<unnamed-type-data>@vpx_codec_cx_pkt@@QEAA@AEBU012@@Z", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecCxPkt.Data.VpxPsnrPkt> NativeToManagedMap =
                    new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecCxPkt.Data.VpxPsnrPkt>();

                internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxCodecCxPkt.Data.VpxPsnrPkt managed)
                {
                    NativeToManagedMap[native] = managed;
                }

                internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxCodecCxPkt.Data.VpxPsnrPkt managed)
                {
    
                    return NativeToManagedMap.TryGetValue(native, out managed);
                }

                protected bool __ownsNativeInstance;

                internal static VpxPsnrPkt __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    return new VpxPsnrPkt(native.ToPointer(), skipVTables);
                }

                internal static VpxPsnrPkt __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (__TryGetNativeToManagedMapping(native, out var managed))
                        return (VpxPsnrPkt)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        __RecordNativeToManagedMapping(native, result);
                    return result;
                }

                internal static VpxPsnrPkt __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new VpxPsnrPkt(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private VpxPsnrPkt(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                protected VpxPsnrPkt(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public VpxPsnrPkt()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                }

                public VpxPsnrPkt(global::Vpx.VpxCodecCxPkt.Data.VpxPsnrPkt _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal));
                    __ownsNativeInstance = true;
                    __RecordNativeToManagedMapping(__Instance, this);
                    *((global::Vpx.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal*) __Instance) = *((global::Vpx.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                /// <summary>Number of samples, total/y/u/v</summary>
                public uint[] Samples
                {
                    get
                    {
                        return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->samples, 4);
                    }

                    set
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 4; i++)
                                ((__Internal*)__Instance)->samples[i] = value[i];
                        }
                    }
                }

                /// <summary>sum squared error, total/y/u/v</summary>
                public ulong[] Sse
                {
                    get
                    {
                        return CppSharp.Runtime.MarshalUtil.GetArray<ulong>(((__Internal*)__Instance)->sse, 4);
                    }

                    set
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 4; i++)
                                ((__Internal*)__Instance)->sse[i] = value[i];
                        }
                    }
                }

                /// <summary>PSNR, total/y/u/v</summary>
                public double[] Psnr
                {
                    get
                    {
                        return CppSharp.Runtime.MarshalUtil.GetArray<double>(((__Internal*)__Instance)->psnr, 4);
                    }

                    set
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 4; i++)
                                ((__Internal*)__Instance)->psnr[i] = value[i];
                        }
                    }
                }
            }

            private Data.__Internal __instance;
            internal ref Data.__Internal __Instance => ref __instance;

            internal static Data __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Data(native.ToPointer(), skipVTables);
            }

            internal static Data __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Data(native, skipVTables);
            }

            private Data(__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private Data(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::Vpx.VpxCodecCxPkt.Data.__Internal*) native;
            }

            public Data(global::Vpx.VpxCodecCxPkt.Data _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new __IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
                }
            }

            /// <summary>data for compressed frame packet</summary>
            public global::Vpx.VpxCodecCxPkt.Data.Frame frame
            {
                get
                {
                    return global::Vpx.VpxCodecCxPkt.Data.Frame.__CreateInstance(__instance.frame);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.frame = *(global::Vpx.VpxCodecCxPkt.Data.Frame.__Internal*) value.__Instance;
                }
            }

            /// <summary>data for two-pass packet</summary>
            public global::Vpx.VpxFixedBuf TwopassStats
            {
                get
                {
                    return global::Vpx.VpxFixedBuf.__CreateInstance(__instance.twopass_stats);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.twopass_stats = *(global::Vpx.VpxFixedBuf.__Internal*) value.__Instance;
                }
            }

            /// <summary>first pass mb packet</summary>
            public global::Vpx.VpxFixedBuf FirstpassMbStats
            {
                get
                {
                    return global::Vpx.VpxFixedBuf.__CreateInstance(__instance.firstpass_mb_stats);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.firstpass_mb_stats = *(global::Vpx.VpxFixedBuf.__Internal*) value.__Instance;
                }
            }

            /// <summary>data for PSNR packet</summary>
            public global::Vpx.VpxCodecCxPkt.Data.VpxPsnrPkt Psnr
            {
                get
                {
                    return global::Vpx.VpxCodecCxPkt.Data.VpxPsnrPkt.__CreateInstance(__instance.psnr);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.psnr = *(global::Vpx.VpxCodecCxPkt.Data.VpxPsnrPkt.__Internal*) value.__Instance;
                }
            }

            /// <summary>data for arbitrary packets</summary>
            public global::Vpx.VpxFixedBuf Raw
            {
                get
                {
                    return global::Vpx.VpxFixedBuf.__CreateInstance(__instance.raw);
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    __instance.raw = *(global::Vpx.VpxFixedBuf.__Internal*) value.__Instance;
                }
            }

            /// <summary>fixed sz</summary>
            public sbyte[] Pad
            {
                get
                {
                    fixed (sbyte* __arrPtr = __instance.pad)
                    {
                        return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(__arrPtr, 124);
                    }
                }

                set
                {
                    fixed (sbyte* __arrPtr = __instance.pad)
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 124; i++)
                                __arrPtr[i] = value[i];
                        }
                    }
                }
            }
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecCxPkt> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecCxPkt>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxCodecCxPkt managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxCodecCxPkt managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxCodecCxPkt __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxCodecCxPkt(native.ToPointer(), skipVTables);
        }

        internal static VpxCodecCxPkt __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxCodecCxPkt)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxCodecCxPkt __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxCodecCxPkt(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxCodecCxPkt(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxCodecCxPkt(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxCodecCxPkt()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxCodecCxPkt.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxCodecCxPkt(global::Vpx.VpxCodecCxPkt _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxCodecCxPkt.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxCodecCxPkt.__Internal*) __Instance) = *((global::Vpx.VpxCodecCxPkt.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>packet variant</summary>
        public global::Vpx.VpxCodecCxPktKind Kind
        {
            get
            {
                return ((__Internal*)__Instance)->kind;
            }

            set
            {
                ((__Internal*)__Instance)->kind = value;
            }
        }

        /// <summary>packet data</summary>
        public global::Vpx.VpxCodecCxPkt.Data data
        {
            get
            {
                return global::Vpx.VpxCodecCxPkt.Data.__CreateInstance(((__Internal*)__Instance)->data);
            }

            set
            {
                ((__Internal*)__Instance)->data = value.__Instance;
            }
        }
    }

    /// <summary>Callback function pointer / user data pair storage</summary>
    public unsafe partial class VpxCodecEncOutputCxCbPair : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr output_cx_pkt;
            internal __IntPtr user_priv;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_codec_enc_output_cx_cb_pair@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecEncOutputCxCbPair> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecEncOutputCxCbPair>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxCodecEncOutputCxCbPair managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxCodecEncOutputCxCbPair managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxCodecEncOutputCxCbPair __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxCodecEncOutputCxCbPair(native.ToPointer(), skipVTables);
        }

        internal static VpxCodecEncOutputCxCbPair __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxCodecEncOutputCxCbPair)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxCodecEncOutputCxCbPair __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxCodecEncOutputCxCbPair(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxCodecEncOutputCxCbPair(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxCodecEncOutputCxCbPair(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxCodecEncOutputCxCbPair()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxCodecEncOutputCxCbPair.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxCodecEncOutputCxCbPair(global::Vpx.VpxCodecEncOutputCxCbPair _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxCodecEncOutputCxCbPair.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxCodecEncOutputCxCbPair.__Internal*) __Instance) = *((global::Vpx.VpxCodecEncOutputCxCbPair.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Callback function</summary>
        public global::Vpx.VpxCodecEncOutputCxPktCbFnT OutputCxPkt
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->output_cx_pkt;
                return __ptr0 == IntPtr.Zero? null : (global::Vpx.VpxCodecEncOutputCxPktCbFnT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Vpx.VpxCodecEncOutputCxPktCbFnT));
            }

            set
            {
                ((__Internal*)__Instance)->output_cx_pkt = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Pointer to private data</summary>
        public __IntPtr UserPriv
        {
            get
            {
                return ((__Internal*)__Instance)->user_priv;
            }

            set
            {
                ((__Internal*)__Instance)->user_priv = (__IntPtr) value;
            }
        }
    }

    /// <summary>Rational Number</summary>
    /// <remarks>This structure holds a fractional value.</remarks>
    public unsafe partial class VpxRational : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal int num;
            internal int den;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_rational@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRational> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRational>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxRational managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxRational managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxRational __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxRational(native.ToPointer(), skipVTables);
        }

        internal static VpxRational __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxRational)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxRational __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxRational(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxRational(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxRational(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxRational()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRational.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxRational(global::Vpx.VpxRational _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRational.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxRational.__Internal*) __Instance) = *((global::Vpx.VpxRational.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>fraction numerator</summary>
        public int Num
        {
            get
            {
                return ((__Internal*)__Instance)->num;
            }

            set
            {
                ((__Internal*)__Instance)->num = value;
            }
        }

        /// <summary>fraction denominator</summary>
        public int Den
        {
            get
            {
                return ((__Internal*)__Instance)->den;
            }

            set
            {
                ((__Internal*)__Instance)->den = value;
            }
        }
    }

    /// <summary>Encoder configuration structure</summary>
    /// <remarks>
    /// <para>This structure contains the encoder settings that have common representations</para>
    /// <para>across all codecs. This doesn't imply that all codecs support all features,</para>
    /// <para>however.</para>
    /// </remarks>
    public unsafe partial class VpxCodecEncCfg : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 504)]
        public partial struct __Internal
        {
            internal uint g_usage;
            internal uint g_threads;
            internal uint g_profile;
            internal uint g_w;
            internal uint g_h;
            internal global::Vpx.VpxBitDepth g_bit_depth;
            internal uint g_input_bit_depth;
            internal global::Vpx.VpxRational.__Internal g_timebase;
            internal uint g_error_resilient;
            internal global::Vpx.VpxEncPass g_pass;
            internal uint g_lag_in_frames;
            internal uint rc_dropframe_thresh;
            internal uint rc_resize_allowed;
            internal uint rc_scaled_width;
            internal uint rc_scaled_height;
            internal uint rc_resize_up_thresh;
            internal uint rc_resize_down_thresh;
            internal global::Vpx.VpxRcMode rc_end_usage;
            internal global::Vpx.VpxFixedBuf.__Internal rc_twopass_stats_in;
            internal global::Vpx.VpxFixedBuf.__Internal rc_firstpass_mb_stats_in;
            internal uint rc_target_bitrate;
            internal uint rc_min_quantizer;
            internal uint rc_max_quantizer;
            internal uint rc_undershoot_pct;
            internal uint rc_overshoot_pct;
            internal uint rc_buf_sz;
            internal uint rc_buf_initial_sz;
            internal uint rc_buf_optimal_sz;
            internal uint rc_2pass_vbr_bias_pct;
            internal uint rc_2pass_vbr_minsection_pct;
            internal uint rc_2pass_vbr_maxsection_pct;
            internal uint rc_2pass_vbr_corpus_complexity;
            internal global::Vpx.VpxKfMode kf_mode;
            internal uint kf_min_dist;
            internal uint kf_max_dist;
            internal uint ss_number_layers;
            internal fixed int ss_enable_auto_alt_ref[5];
            internal fixed uint ss_target_bitrate[5];
            internal uint ts_number_layers;
            internal fixed uint ts_target_bitrate[5];
            internal fixed uint ts_rate_decimator[5];
            internal uint ts_periodicity;
            internal fixed uint ts_layer_id[16];
            internal fixed uint layer_target_bitrate[12];
            internal int temporal_layering_mode;
            internal int use_vizier_rc_params;
            internal global::Vpx.VpxRational.__Internal active_wq_factor;
            internal global::Vpx.VpxRational.__Internal err_per_mb_factor;
            internal global::Vpx.VpxRational.__Internal sr_default_decay_limit;
            internal global::Vpx.VpxRational.__Internal sr_diff_factor;
            internal global::Vpx.VpxRational.__Internal kf_err_per_mb_factor;
            internal global::Vpx.VpxRational.__Internal kf_frame_min_boost_factor;
            internal global::Vpx.VpxRational.__Internal kf_frame_max_boost_first_factor;
            internal global::Vpx.VpxRational.__Internal kf_frame_max_boost_subs_factor;
            internal global::Vpx.VpxRational.__Internal kf_max_total_boost_factor;
            internal global::Vpx.VpxRational.__Internal gf_max_total_boost_factor;
            internal global::Vpx.VpxRational.__Internal gf_frame_max_boost_factor;
            internal global::Vpx.VpxRational.__Internal zm_factor;
            internal global::Vpx.VpxRational.__Internal rd_mult_inter_qp_fac;
            internal global::Vpx.VpxRational.__Internal rd_mult_arf_qp_fac;
            internal global::Vpx.VpxRational.__Internal rd_mult_key_qp_fac;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_codec_enc_cfg@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecEncCfg> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxCodecEncCfg>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxCodecEncCfg managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxCodecEncCfg managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxCodecEncCfg __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxCodecEncCfg(native.ToPointer(), skipVTables);
        }

        internal static VpxCodecEncCfg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxCodecEncCfg)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxCodecEncCfg __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxCodecEncCfg(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxCodecEncCfg(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxCodecEncCfg(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxCodecEncCfg()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxCodecEncCfg.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxCodecEncCfg(global::Vpx.VpxCodecEncCfg _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxCodecEncCfg.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxCodecEncCfg.__Internal*) __Instance) = *((global::Vpx.VpxCodecEncCfg.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Deprecated: Algorithm specific &quot;usage&quot; value</summary>
        /// <remarks>This value must be zero.</remarks>
        public uint GUsage
        {
            get
            {
                return ((__Internal*)__Instance)->g_usage;
            }

            set
            {
                ((__Internal*)__Instance)->g_usage = value;
            }
        }

        /// <summary>Maximum number of threads to use</summary>
        /// <remarks>
        /// <para>For multi-threaded implementations, use no more than this number of</para>
        /// <para>threads. The codec may use fewer threads than allowed. The value</para>
        /// <para>0 is equivalent to the value 1.</para>
        /// </remarks>
        public uint GThreads
        {
            get
            {
                return ((__Internal*)__Instance)->g_threads;
            }

            set
            {
                ((__Internal*)__Instance)->g_threads = value;
            }
        }

        /// <summary>profile of bitstream to use</summary>
        public uint GProfile
        {
            get
            {
                return ((__Internal*)__Instance)->g_profile;
            }

            set
            {
                ((__Internal*)__Instance)->g_profile = value;
            }
        }

        /// <summary>Width of the frame</summary>
        /// <remarks>
        /// <para>This value identifies the presentation resolution of the frame,</para>
        /// <para>in pixels. Note that the frames passed as input to the encoder must</para>
        /// <para>have this resolution. Frames will be presented by the decoder in this</para>
        /// <para>resolution, independent of any spatial resampling the encoder may do.</para>
        /// </remarks>
        public uint GW
        {
            get
            {
                return ((__Internal*)__Instance)->g_w;
            }

            set
            {
                ((__Internal*)__Instance)->g_w = value;
            }
        }

        /// <summary>Height of the frame</summary>
        /// <remarks>
        /// <para>This value identifies the presentation resolution of the frame,</para>
        /// <para>in pixels. Note that the frames passed as input to the encoder must</para>
        /// <para>have this resolution. Frames will be presented by the decoder in this</para>
        /// <para>resolution, independent of any spatial resampling the encoder may do.</para>
        /// </remarks>
        public uint GH
        {
            get
            {
                return ((__Internal*)__Instance)->g_h;
            }

            set
            {
                ((__Internal*)__Instance)->g_h = value;
            }
        }

        /// <summary>Bit-depth of the codec</summary>
        /// <remarks>
        /// <para>This value identifies the bit_depth of the codec,</para>
        /// <para>Only certain bit-depths are supported as identified in the</para>
        /// <para>vpx_bit_depth_t enum.</para>
        /// </remarks>
        public global::Vpx.VpxBitDepth GBitDepth
        {
            get
            {
                return ((__Internal*)__Instance)->g_bit_depth;
            }

            set
            {
                ((__Internal*)__Instance)->g_bit_depth = value;
            }
        }

        /// <summary>Bit-depth of the input frames</summary>
        /// <remarks>
        /// <para>This value identifies the bit_depth of the input frames in bits.</para>
        /// <para>Note that the frames passed as input to the encoder must have</para>
        /// <para>this bit-depth.</para>
        /// </remarks>
        public uint GInputBitDepth
        {
            get
            {
                return ((__Internal*)__Instance)->g_input_bit_depth;
            }

            set
            {
                ((__Internal*)__Instance)->g_input_bit_depth = value;
            }
        }

        /// <summary>Stream timebase units</summary>
        /// <remarks>
        /// <para>Indicates the smallest interval of time, in seconds, used by the stream.</para>
        /// <para>For fixed frame rate material, or variable frame rate material where</para>
        /// <para>frames are timed at a multiple of a given clock (ex: video capture),</para>
        /// <para>themethod is to set the timebase to the reciprocal</para>
        /// <para>of the frame rate (ex: 1001/30000 for 29.970 Hz NTSC). This allows the</para>
        /// <para>pts to correspond to the frame number, which can be handy. For</para>
        /// <para>re-encoding video from containers with absolute time timestamps, the</para>
        /// <para>method is to set the timebase to that of the parent</para>
        /// <para>container or multimedia framework (ex: 1/1000 for ms, as in FLV).</para>
        /// </remarks>
        public global::Vpx.VpxRational GTimebase
        {
            get
            {
                return global::Vpx.VpxRational.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->g_timebase));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->g_timebase = *(global::Vpx.VpxRational.__Internal*) value.__Instance;
            }
        }

        /// <summary>Enable error resilient modes.</summary>
        /// <remarks>
        /// <para>The error resilient bitfield indicates to the encoder which features</para>
        /// <para>it should enable to take measures for streaming over lossy or noisy</para>
        /// <para>links.</para>
        /// </remarks>
        public uint GErrorResilient
        {
            get
            {
                return ((__Internal*)__Instance)->g_error_resilient;
            }

            set
            {
                ((__Internal*)__Instance)->g_error_resilient = value;
            }
        }

        /// <summary>Multi-pass Encoding Mode</summary>
        /// <remarks>
        /// <para>This value should be set to the current phase for multi-pass encoding.</para>
        /// <para>For single pass, set to #VPX_RC_ONE_PASS.</para>
        /// </remarks>
        public global::Vpx.VpxEncPass GPass
        {
            get
            {
                return ((__Internal*)__Instance)->g_pass;
            }

            set
            {
                ((__Internal*)__Instance)->g_pass = value;
            }
        }

        /// <summary>Allow lagged encoding</summary>
        /// <remarks>
        /// <para>If set, this value allows the encoder to consume a number of input</para>
        /// <para>frames before producing output frames. This allows the encoder to</para>
        /// <para>base decisions for the current frame on future frames. This does</para>
        /// <para>increase the latency of the encoding pipeline, so it is not appropriate</para>
        /// <para>in all situations (ex: realtime encoding).</para>
        /// <para>Note that this is a maximum value -- the encoder may produce frames</para>
        /// <para>sooner than the given limit. Set this value to 0 to disable this</para>
        /// <para>feature.</para>
        /// </remarks>
        public uint GLagInFrames
        {
            get
            {
                return ((__Internal*)__Instance)->g_lag_in_frames;
            }

            set
            {
                ((__Internal*)__Instance)->g_lag_in_frames = value;
            }
        }

        /// <summary>Temporal resampling configuration, if supported by the codec.</summary>
        /// <remarks>
        /// <para>Temporal resampling allows the codec to &quot;drop&quot; frames as a strategy to</para>
        /// <para>meet its target data rate. This can cause temporal discontinuities in</para>
        /// <para>the encoded video, which may appear as stuttering during playback. This</para>
        /// <para>trade-off is often acceptable, but for many applications is not. It can</para>
        /// <para>be disabled in these cases.</para>
        /// <para>This threshold is described as a percentage of the target data buffer.</para>
        /// <para>When the data buffer falls below this percentage of fullness, a</para>
        /// <para>dropped frame is indicated. Set the threshold to zero (0) to disable</para>
        /// <para>this feature.</para>
        /// </remarks>
        public uint RcDropframeThresh
        {
            get
            {
                return ((__Internal*)__Instance)->rc_dropframe_thresh;
            }

            set
            {
                ((__Internal*)__Instance)->rc_dropframe_thresh = value;
            }
        }

        /// <summary>Enable/disable spatial resampling, if supported by the codec.</summary>
        /// <remarks>
        /// <para>Spatial resampling allows the codec to compress a lower resolution</para>
        /// <para>version of the frame, which is then upscaled by the encoder to the</para>
        /// <para>correct presentation resolution. This increases visual quality at</para>
        /// <para>low data rates, at the expense of CPU time on the encoder/decoder.</para>
        /// </remarks>
        public uint RcResizeAllowed
        {
            get
            {
                return ((__Internal*)__Instance)->rc_resize_allowed;
            }

            set
            {
                ((__Internal*)__Instance)->rc_resize_allowed = value;
            }
        }

        /// <summary>Internal coded frame width.</summary>
        /// <remarks>
        /// <para>If spatial resampling is enabled this specifies the width of the</para>
        /// <para>encoded frame.</para>
        /// </remarks>
        public uint RcScaledWidth
        {
            get
            {
                return ((__Internal*)__Instance)->rc_scaled_width;
            }

            set
            {
                ((__Internal*)__Instance)->rc_scaled_width = value;
            }
        }

        /// <summary>Internal coded frame height.</summary>
        /// <remarks>
        /// <para>If spatial resampling is enabled this specifies the height of the</para>
        /// <para>encoded frame.</para>
        /// </remarks>
        public uint RcScaledHeight
        {
            get
            {
                return ((__Internal*)__Instance)->rc_scaled_height;
            }

            set
            {
                ((__Internal*)__Instance)->rc_scaled_height = value;
            }
        }

        /// <summary>Spatial resampling up watermark.</summary>
        /// <remarks>
        /// <para>This threshold is described as a percentage of the target data buffer.</para>
        /// <para>When the data buffer rises above this percentage of fullness, the</para>
        /// <para>encoder will step up to a higher resolution version of the frame.</para>
        /// </remarks>
        public uint RcResizeUpThresh
        {
            get
            {
                return ((__Internal*)__Instance)->rc_resize_up_thresh;
            }

            set
            {
                ((__Internal*)__Instance)->rc_resize_up_thresh = value;
            }
        }

        /// <summary>Spatial resampling down watermark.</summary>
        /// <remarks>
        /// <para>This threshold is described as a percentage of the target data buffer.</para>
        /// <para>When the data buffer falls below this percentage of fullness, the</para>
        /// <para>encoder will step down to a lower resolution version of the frame.</para>
        /// </remarks>
        public uint RcResizeDownThresh
        {
            get
            {
                return ((__Internal*)__Instance)->rc_resize_down_thresh;
            }

            set
            {
                ((__Internal*)__Instance)->rc_resize_down_thresh = value;
            }
        }

        /// <summary>Rate control algorithm to use.</summary>
        /// <remarks>
        /// <para>Indicates whether the end usage of this stream is to be streamed over</para>
        /// <para>a bandwidth constrained link, indicating that Constant Bit Rate (CBR)</para>
        /// <para>mode should be used, or whether it will be played back on a high</para>
        /// <para>bandwidth link, as from a local disk, where higher variations in</para>
        /// <para>bitrate are acceptable.</para>
        /// </remarks>
        public global::Vpx.VpxRcMode RcEndUsage
        {
            get
            {
                return ((__Internal*)__Instance)->rc_end_usage;
            }

            set
            {
                ((__Internal*)__Instance)->rc_end_usage = value;
            }
        }

        /// <summary>Two-pass stats buffer.</summary>
        /// <remarks>
        /// <para>A buffer containing all of the stats packets produced in the first</para>
        /// <para>pass, concatenated.</para>
        /// </remarks>
        public global::Vpx.VpxFixedBuf RcTwopassStatsIn
        {
            get
            {
                return global::Vpx.VpxFixedBuf.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->rc_twopass_stats_in));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->rc_twopass_stats_in = *(global::Vpx.VpxFixedBuf.__Internal*) value.__Instance;
            }
        }

        /// <summary>first pass mb stats buffer.</summary>
        /// <remarks>
        /// <para>A buffer containing all of the first pass mb stats packets produced</para>
        /// <para>in the first pass, concatenated.</para>
        /// </remarks>
        public global::Vpx.VpxFixedBuf RcFirstpassMbStatsIn
        {
            get
            {
                return global::Vpx.VpxFixedBuf.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->rc_firstpass_mb_stats_in));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->rc_firstpass_mb_stats_in = *(global::Vpx.VpxFixedBuf.__Internal*) value.__Instance;
            }
        }

        /// <summary>Target data rate</summary>
        /// <remarks>Target bitrate to use for this stream, in kilobits per second.</remarks>
        public uint RcTargetBitrate
        {
            get
            {
                return ((__Internal*)__Instance)->rc_target_bitrate;
            }

            set
            {
                ((__Internal*)__Instance)->rc_target_bitrate = value;
            }
        }

        /// <summary>Minimum (Best Quality) Quantizer</summary>
        /// <remarks>
        /// <para>The quantizer is the most direct control over the quality of the</para>
        /// <para>encoded image. The range of valid values for the quantizer is codec</para>
        /// <para>specific. Consult the documentation for the codec to determine the</para>
        /// <para>values to use.</para>
        /// </remarks>
        public uint RcMinQuantizer
        {
            get
            {
                return ((__Internal*)__Instance)->rc_min_quantizer;
            }

            set
            {
                ((__Internal*)__Instance)->rc_min_quantizer = value;
            }
        }

        /// <summary>Maximum (Worst Quality) Quantizer</summary>
        /// <remarks>
        /// <para>The quantizer is the most direct control over the quality of the</para>
        /// <para>encoded image. The range of valid values for the quantizer is codec</para>
        /// <para>specific. Consult the documentation for the codec to determine the</para>
        /// <para>values to use.</para>
        /// </remarks>
        public uint RcMaxQuantizer
        {
            get
            {
                return ((__Internal*)__Instance)->rc_max_quantizer;
            }

            set
            {
                ((__Internal*)__Instance)->rc_max_quantizer = value;
            }
        }

        /// <summary>Rate control adaptation undershoot control</summary>
        /// <remarks>
        /// <para>VP8: Expressed as a percentage of the target bitrate,</para>
        /// <para>controls the maximum allowed adaptation speed of the codec.</para>
        /// <para>This factor controls the maximum amount of bits that can</para>
        /// <para>be subtracted from the target bitrate in order to compensate</para>
        /// <para>for prior overshoot.</para>
        /// <para>VP9: Expressed as a percentage of the target bitrate, a threshold</para>
        /// <para>undershoot level (current rate vs target) beyond which more aggressive</para>
        /// <para>corrective measures are taken.</para>
        /// <para>*</para>
        /// <para>Valid values in the range VP8:0-100 VP9: 0-100.</para>
        /// </remarks>
        public uint RcUndershootPct
        {
            get
            {
                return ((__Internal*)__Instance)->rc_undershoot_pct;
            }

            set
            {
                ((__Internal*)__Instance)->rc_undershoot_pct = value;
            }
        }

        /// <summary>Rate control adaptation overshoot control</summary>
        /// <remarks>
        /// <para>VP8: Expressed as a percentage of the target bitrate,</para>
        /// <para>controls the maximum allowed adaptation speed of the codec.</para>
        /// <para>This factor controls the maximum amount of bits that can</para>
        /// <para>be added to the target bitrate in order to compensate for</para>
        /// <para>prior undershoot.</para>
        /// <para>VP9: Expressed as a percentage of the target bitrate, a threshold</para>
        /// <para>overshoot level (current rate vs target) beyond which more aggressive</para>
        /// <para>corrective measures are taken.</para>
        /// <para>Valid values in the range VP8:0-100 VP9: 0-100.</para>
        /// </remarks>
        public uint RcOvershootPct
        {
            get
            {
                return ((__Internal*)__Instance)->rc_overshoot_pct;
            }

            set
            {
                ((__Internal*)__Instance)->rc_overshoot_pct = value;
            }
        }

        /// <summary>Decoder Buffer Size</summary>
        /// <remarks>
        /// <para>This value indicates the amount of data that may be buffered by the</para>
        /// <para>decoding application. Note that this value is expressed in units of</para>
        /// <para>time (milliseconds). For example, a value of 5000 indicates that the</para>
        /// <para>client will buffer (at least) 5000ms worth of encoded data. Use the</para>
        /// <para>target bitrate (#rc_target_bitrate) to convert to bits/bytes, if</para>
        /// <para>necessary.</para>
        /// </remarks>
        public uint RcBufSz
        {
            get
            {
                return ((__Internal*)__Instance)->rc_buf_sz;
            }

            set
            {
                ((__Internal*)__Instance)->rc_buf_sz = value;
            }
        }

        /// <summary>Decoder Buffer Initial Size</summary>
        /// <remarks>
        /// <para>This value indicates the amount of data that will be buffered by the</para>
        /// <para>decoding application prior to beginning playback. This value is</para>
        /// <para>expressed in units of time (milliseconds). Use the target bitrate</para>
        /// <para>(#rc_target_bitrate) to convert to bits/bytes, if necessary.</para>
        /// </remarks>
        public uint RcBufInitialSz
        {
            get
            {
                return ((__Internal*)__Instance)->rc_buf_initial_sz;
            }

            set
            {
                ((__Internal*)__Instance)->rc_buf_initial_sz = value;
            }
        }

        /// <summary>Decoder Buffer Optimal Size</summary>
        /// <remarks>
        /// <para>This value indicates the amount of data that the encoder should try</para>
        /// <para>to maintain in the decoder's buffer. This value is expressed in units</para>
        /// <para>of time (milliseconds). Use the target bitrate (#rc_target_bitrate)</para>
        /// <para>to convert to bits/bytes, if necessary.</para>
        /// </remarks>
        public uint RcBufOptimalSz
        {
            get
            {
                return ((__Internal*)__Instance)->rc_buf_optimal_sz;
            }

            set
            {
                ((__Internal*)__Instance)->rc_buf_optimal_sz = value;
            }
        }

        /// <summary>Two-pass mode CBR/VBR bias</summary>
        /// <remarks>
        /// <para>Bias, expressed on a scale of 0 to 100, for determining target size</para>
        /// <para>for the current frame. The value 0 indicates the optimal CBR mode</para>
        /// <para>value should be used. The value 100 indicates the optimal VBR mode</para>
        /// <para>value should be used. Values in between indicate which way the</para>
        /// <para>encoder should &quot;lean.&quot;</para>
        /// </remarks>
        public uint Rc2passVbrBiasPct
        {
            get
            {
                return ((__Internal*)__Instance)->rc_2pass_vbr_bias_pct;
            }

            set
            {
                ((__Internal*)__Instance)->rc_2pass_vbr_bias_pct = value;
            }
        }

        /// <summary>Two-pass mode per-GOP minimum bitrate</summary>
        /// <remarks>
        /// <para>This value, expressed as a percentage of the target bitrate, indicates</para>
        /// <para>the minimum bitrate to be used for a single GOP (aka &quot;section&quot;)</para>
        /// </remarks>
        public uint Rc2passVbrMinsectionPct
        {
            get
            {
                return ((__Internal*)__Instance)->rc_2pass_vbr_minsection_pct;
            }

            set
            {
                ((__Internal*)__Instance)->rc_2pass_vbr_minsection_pct = value;
            }
        }

        /// <summary>Two-pass mode per-GOP maximum bitrate</summary>
        /// <remarks>
        /// <para>This value, expressed as a percentage of the target bitrate, indicates</para>
        /// <para>the maximum bitrate to be used for a single GOP (aka &quot;section&quot;)</para>
        /// </remarks>
        public uint Rc2passVbrMaxsectionPct
        {
            get
            {
                return ((__Internal*)__Instance)->rc_2pass_vbr_maxsection_pct;
            }

            set
            {
                ((__Internal*)__Instance)->rc_2pass_vbr_maxsection_pct = value;
            }
        }

        /// <summary>
        /// <para>Two-pass corpus vbr mode complexity control</para>
        /// <para>Used only in VP9: A value representing the corpus midpoint complexity</para>
        /// <para>for corpus vbr mode. This value defaults to 0 which disables corpus vbr</para>
        /// <para>mode in favour of normal vbr mode.</para>
        /// </summary>
        public uint Rc2passVbrCorpusComplexity
        {
            get
            {
                return ((__Internal*)__Instance)->rc_2pass_vbr_corpus_complexity;
            }

            set
            {
                ((__Internal*)__Instance)->rc_2pass_vbr_corpus_complexity = value;
            }
        }

        /// <summary>Keyframe placement mode</summary>
        /// <remarks>
        /// <para>This value indicates whether the encoder should place keyframes at a</para>
        /// <para>fixed interval, or determine the optimal placement automatically</para>
        /// <para>(as governed by the #kf_min_dist and #kf_max_dist parameters)</para>
        /// </remarks>
        public global::Vpx.VpxKfMode KfMode
        {
            get
            {
                return ((__Internal*)__Instance)->kf_mode;
            }

            set
            {
                ((__Internal*)__Instance)->kf_mode = value;
            }
        }

        /// <summary>Keyframe minimum interval</summary>
        /// <remarks>
        /// <para>This value, expressed as a number of frames, prevents the encoder from</para>
        /// <para>placing a keyframe nearer than kf_min_dist to the previous keyframe. At</para>
        /// <para>least kf_min_dist frames non-keyframes will be coded before the next</para>
        /// <para>keyframe. Set kf_min_dist equal to kf_max_dist for a fixed interval.</para>
        /// </remarks>
        public uint KfMinDist
        {
            get
            {
                return ((__Internal*)__Instance)->kf_min_dist;
            }

            set
            {
                ((__Internal*)__Instance)->kf_min_dist = value;
            }
        }

        /// <summary>Keyframe maximum interval</summary>
        /// <remarks>
        /// <para>This value, expressed as a number of frames, forces the encoder to code</para>
        /// <para>a keyframe if one has not been coded in the last kf_max_dist frames.</para>
        /// <para>A value of 0 implies all frames will be keyframes. Set kf_min_dist</para>
        /// <para>equal to kf_max_dist for a fixed interval.</para>
        /// </remarks>
        public uint KfMaxDist
        {
            get
            {
                return ((__Internal*)__Instance)->kf_max_dist;
            }

            set
            {
                ((__Internal*)__Instance)->kf_max_dist = value;
            }
        }

        /// <summary>Number of spatial coding layers.</summary>
        /// <remarks>This value specifies the number of spatial coding layers to be used.</remarks>
        public uint SsNumberLayers
        {
            get
            {
                return ((__Internal*)__Instance)->ss_number_layers;
            }

            set
            {
                ((__Internal*)__Instance)->ss_number_layers = value;
            }
        }

        /// <summary>Enable auto alt reference flags for each spatial layer.</summary>
        /// <remarks>
        /// <para>These values specify if auto alt reference frame is enabled for each</para>
        /// <para>spatial layer.</para>
        /// </remarks>
        public int[] SsEnableAutoAltRef
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->ss_enable_auto_alt_ref, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->ss_enable_auto_alt_ref[i] = value[i];
                }
            }
        }

        /// <summary>Target bitrate for each spatial layer.</summary>
        /// <remarks>
        /// <para>These values specify the target coding bitrate to be used for each</para>
        /// <para>spatial layer. (in kbps)</para>
        /// </remarks>
        public uint[] SsTargetBitrate
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->ss_target_bitrate, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->ss_target_bitrate[i] = value[i];
                }
            }
        }

        /// <summary>Number of temporal coding layers.</summary>
        /// <remarks>This value specifies the number of temporal layers to be used.</remarks>
        public uint TsNumberLayers
        {
            get
            {
                return ((__Internal*)__Instance)->ts_number_layers;
            }

            set
            {
                ((__Internal*)__Instance)->ts_number_layers = value;
            }
        }

        /// <summary>Target bitrate for each temporal layer.</summary>
        /// <remarks>
        /// <para>These values specify the target coding bitrate to be used for each</para>
        /// <para>temporal layer. (in kbps)</para>
        /// </remarks>
        public uint[] TsTargetBitrate
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->ts_target_bitrate, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->ts_target_bitrate[i] = value[i];
                }
            }
        }

        /// <summary>Frame rate decimation factor for each temporal layer.</summary>
        /// <remarks>
        /// <para>These values specify the frame rate decimation factors to apply</para>
        /// <para>to each temporal layer.</para>
        /// </remarks>
        public uint[] TsRateDecimator
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->ts_rate_decimator, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->ts_rate_decimator[i] = value[i];
                }
            }
        }

        /// <summary>Length of the sequence defining frame temporal layer membership.</summary>
        /// <remarks>
        /// <para>This value specifies the length of the sequence that defines the</para>
        /// <para>membership of frames to temporal layers. For example, if the</para>
        /// <para>ts_periodicity = 8, then the frames are assigned to coding layers with a</para>
        /// <para>repeated sequence of length 8.</para>
        /// </remarks>
        public uint TsPeriodicity
        {
            get
            {
                return ((__Internal*)__Instance)->ts_periodicity;
            }

            set
            {
                ((__Internal*)__Instance)->ts_periodicity = value;
            }
        }

        /// <summary>Template defining the membership of frames to temporal layers.</summary>
        /// <remarks>
        /// <para>This array defines the membership of frames to temporal coding layers.</para>
        /// <para>For a 2-layer encoding that assigns even numbered frames to one temporal</para>
        /// <para>layer (0) and odd numbered frames to a second temporal layer (1) with</para>
        /// <para>ts_periodicity=8, then ts_layer_id = (0,1,0,1,0,1,0,1).</para>
        /// </remarks>
        public uint[] TsLayerId
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->ts_layer_id, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->ts_layer_id[i] = value[i];
                }
            }
        }

        /// <summary>Target bitrate for each spatial/temporal layer.</summary>
        /// <remarks>
        /// <para>These values specify the target coding bitrate to be used for each</para>
        /// <para>spatial/temporal layer. (in kbps)</para>
        /// </remarks>
        public uint[] LayerTargetBitrate
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->layer_target_bitrate, 12);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 12; i++)
                        ((__Internal*)__Instance)->layer_target_bitrate[i] = value[i];
                }
            }
        }

        /// <summary>
        /// <para>Temporal layering mode indicating which temporal layering scheme to</para>
        /// <para>use.</para>
        /// </summary>
        /// <remarks>
        /// <para>The value (refer to VP9E_TEMPORAL_LAYERING_MODE) specifies the</para>
        /// <para>temporal layering mode to use.</para>
        /// </remarks>
        public int TemporalLayeringMode
        {
            get
            {
                return ((__Internal*)__Instance)->temporal_layering_mode;
            }

            set
            {
                ((__Internal*)__Instance)->temporal_layering_mode = value;
            }
        }

        /// <summary>
        /// <para>A flag indicating whether to use external rate control parameters.</para>
        /// <para>By default is 0. If set to 1, the following parameters will be used in the</para>
        /// <para>rate control system.</para>
        /// </summary>
        public int UseVizierRcParams
        {
            get
            {
                return ((__Internal*)__Instance)->use_vizier_rc_params;
            }

            set
            {
                ((__Internal*)__Instance)->use_vizier_rc_params = value;
            }
        }

        /// <summary>Active worst quality factor.</summary>
        /// <remarks>
        /// <para>Rate control parameters, set from external experiment results.</para>
        /// <para>Only when |use_vizier_rc_params| is set to 1, the pass in value will be</para>
        /// <para>used. Otherwise, the default value is used.</para>
        /// </remarks>
        public global::Vpx.VpxRational ActiveWqFactor
        {
            get
            {
                return global::Vpx.VpxRational.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->active_wq_factor));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->active_wq_factor = *(global::Vpx.VpxRational.__Internal*) value.__Instance;
            }
        }

        /// <summary>Error per macroblock adjustment factor.</summary>
        /// <remarks>
        /// <para>Rate control parameters, set from external experiment results.</para>
        /// <para>Only when |use_vizier_rc_params| is set to 1, the pass in value will be</para>
        /// <para>used. Otherwise, the default value is used.</para>
        /// </remarks>
        public global::Vpx.VpxRational ErrPerMbFactor
        {
            get
            {
                return global::Vpx.VpxRational.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->err_per_mb_factor));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->err_per_mb_factor = *(global::Vpx.VpxRational.__Internal*) value.__Instance;
            }
        }

        /// <summary>Second reference default decay limit.</summary>
        /// <remarks>
        /// <para>Rate control parameters, set from external experiment results.</para>
        /// <para>Only when |use_vizier_rc_params| is set to 1, the pass in value will be</para>
        /// <para>used. Otherwise, the default value is used.</para>
        /// </remarks>
        public global::Vpx.VpxRational SrDefaultDecayLimit
        {
            get
            {
                return global::Vpx.VpxRational.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sr_default_decay_limit));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sr_default_decay_limit = *(global::Vpx.VpxRational.__Internal*) value.__Instance;
            }
        }

        /// <summary>Second reference difference factor.</summary>
        /// <remarks>
        /// <para>Rate control parameters, set from external experiment results.</para>
        /// <para>Only when |use_vizier_rc_params| is set to 1, the pass in value will be</para>
        /// <para>used. Otherwise, the default value is used.</para>
        /// </remarks>
        public global::Vpx.VpxRational SrDiffFactor
        {
            get
            {
                return global::Vpx.VpxRational.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->sr_diff_factor));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->sr_diff_factor = *(global::Vpx.VpxRational.__Internal*) value.__Instance;
            }
        }

        /// <summary>Keyframe error per macroblock adjustment factor.</summary>
        /// <remarks>
        /// <para>Rate control parameters, set from external experiment results.</para>
        /// <para>Only when |use_vizier_rc_params| is set to 1, the pass in value will be</para>
        /// <para>used. Otherwise, the default value is used.</para>
        /// </remarks>
        public global::Vpx.VpxRational KfErrPerMbFactor
        {
            get
            {
                return global::Vpx.VpxRational.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->kf_err_per_mb_factor));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->kf_err_per_mb_factor = *(global::Vpx.VpxRational.__Internal*) value.__Instance;
            }
        }

        /// <summary>Keyframe minimum boost adjustment factor.</summary>
        /// <remarks>
        /// <para>Rate control parameters, set from external experiment results.</para>
        /// <para>Only when |use_vizier_rc_params| is set to 1, the pass in value will be</para>
        /// <para>used. Otherwise, the default value is used.</para>
        /// </remarks>
        public global::Vpx.VpxRational KfFrameMinBoostFactor
        {
            get
            {
                return global::Vpx.VpxRational.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->kf_frame_min_boost_factor));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->kf_frame_min_boost_factor = *(global::Vpx.VpxRational.__Internal*) value.__Instance;
            }
        }

        /// <summary>
        /// <para>Keyframe maximum boost adjustment factor, for the first keyframe</para>
        /// <para>in a chunk.</para>
        /// </summary>
        /// <remarks>
        /// <para>Rate control parameters, set from external experiment results.</para>
        /// <para>Only when |use_vizier_rc_params| is set to 1, the pass in value will be</para>
        /// <para>used. Otherwise, the default value is used.</para>
        /// </remarks>
        public global::Vpx.VpxRational KfFrameMaxBoostFirstFactor
        {
            get
            {
                return global::Vpx.VpxRational.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->kf_frame_max_boost_first_factor));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->kf_frame_max_boost_first_factor = *(global::Vpx.VpxRational.__Internal*) value.__Instance;
            }
        }

        /// <summary>Keyframe maximum boost adjustment factor, for subsequent keyframes.</summary>
        /// <remarks>
        /// <para>Rate control parameters, set from external experiment results.</para>
        /// <para>Only when |use_vizier_rc_params| is set to 1, the pass in value will be</para>
        /// <para>used. Otherwise, the default value is used.</para>
        /// </remarks>
        public global::Vpx.VpxRational KfFrameMaxBoostSubsFactor
        {
            get
            {
                return global::Vpx.VpxRational.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->kf_frame_max_boost_subs_factor));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->kf_frame_max_boost_subs_factor = *(global::Vpx.VpxRational.__Internal*) value.__Instance;
            }
        }

        /// <summary>Keyframe maximum total boost adjustment factor.</summary>
        /// <remarks>
        /// <para>Rate control parameters, set from external experiment results.</para>
        /// <para>Only when |use_vizier_rc_params| is set to 1, the pass in value will be</para>
        /// <para>used. Otherwise, the default value is used.</para>
        /// </remarks>
        public global::Vpx.VpxRational KfMaxTotalBoostFactor
        {
            get
            {
                return global::Vpx.VpxRational.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->kf_max_total_boost_factor));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->kf_max_total_boost_factor = *(global::Vpx.VpxRational.__Internal*) value.__Instance;
            }
        }

        /// <summary>Golden frame maximum total boost adjustment factor.</summary>
        /// <remarks>
        /// <para>Rate control parameters, set from external experiment results.</para>
        /// <para>Only when |use_vizier_rc_params| is set to 1, the pass in value will be</para>
        /// <para>used. Otherwise, the default value is used.</para>
        /// </remarks>
        public global::Vpx.VpxRational GfMaxTotalBoostFactor
        {
            get
            {
                return global::Vpx.VpxRational.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->gf_max_total_boost_factor));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->gf_max_total_boost_factor = *(global::Vpx.VpxRational.__Internal*) value.__Instance;
            }
        }

        /// <summary>Golden frame maximum boost adjustment factor.</summary>
        /// <remarks>
        /// <para>Rate control parameters, set from external experiment results.</para>
        /// <para>Only when |use_vizier_rc_params| is set to 1, the pass in value will be</para>
        /// <para>used. Otherwise, the default value is used.</para>
        /// </remarks>
        public global::Vpx.VpxRational GfFrameMaxBoostFactor
        {
            get
            {
                return global::Vpx.VpxRational.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->gf_frame_max_boost_factor));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->gf_frame_max_boost_factor = *(global::Vpx.VpxRational.__Internal*) value.__Instance;
            }
        }

        /// <summary>Zero motion power factor.</summary>
        /// <remarks>
        /// <para>Rate control parameters, set from external experiment results.</para>
        /// <para>Only when |use_vizier_rc_params| is set to 1, the pass in value will be</para>
        /// <para>used. Otherwise, the default value is used.</para>
        /// </remarks>
        public global::Vpx.VpxRational ZmFactor
        {
            get
            {
                return global::Vpx.VpxRational.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->zm_factor));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->zm_factor = *(global::Vpx.VpxRational.__Internal*) value.__Instance;
            }
        }

        /// <summary>
        /// <para>Rate-distortion multiplier for inter frames.</para>
        /// <para>The multiplier is a crucial parameter in the calculation of rate distortion</para>
        /// <para>cost. It is often related to the qp (qindex) value.</para>
        /// <para>Rate control parameters, could be set from external experiment results.</para>
        /// <para>Only when |use_vizier_rc_params| is set to 1, the pass in value will be</para>
        /// <para>used. Otherwise, the default value is used.</para>
        /// </summary>
        public global::Vpx.VpxRational RdMultInterQpFac
        {
            get
            {
                return global::Vpx.VpxRational.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->rd_mult_inter_qp_fac));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->rd_mult_inter_qp_fac = *(global::Vpx.VpxRational.__Internal*) value.__Instance;
            }
        }

        /// <summary>
        /// <para>Rate-distortion multiplier for alt-ref frames.</para>
        /// <para>The multiplier is a crucial parameter in the calculation of rate distortion</para>
        /// <para>cost. It is often related to the qp (qindex) value.</para>
        /// <para>Rate control parameters, could be set from external experiment results.</para>
        /// <para>Only when |use_vizier_rc_params| is set to 1, the pass in value will be</para>
        /// <para>used. Otherwise, the default value is used.</para>
        /// </summary>
        public global::Vpx.VpxRational RdMultArfQpFac
        {
            get
            {
                return global::Vpx.VpxRational.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->rd_mult_arf_qp_fac));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->rd_mult_arf_qp_fac = *(global::Vpx.VpxRational.__Internal*) value.__Instance;
            }
        }

        /// <summary>
        /// <para>Rate-distortion multiplier for key frames.</para>
        /// <para>The multiplier is a crucial parameter in the calculation of rate distortion</para>
        /// <para>cost. It is often related to the qp (qindex) value.</para>
        /// <para>Rate control parameters, could be set from external experiment results.</para>
        /// <para>Only when |use_vizier_rc_params| is set to 1, the pass in value will be</para>
        /// <para>used. Otherwise, the default value is used.</para>
        /// </summary>
        public global::Vpx.VpxRational RdMultKeyQpFac
        {
            get
            {
                return global::Vpx.VpxRational.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->rd_mult_key_qp_fac));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->rd_mult_key_qp_fac = *(global::Vpx.VpxRational.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>vp9 svc extra configure parameters</summary>
    /// <remarks>This defines max/min quantizers and scale factors for each layer</remarks>
    public unsafe partial class VpxSvcParameters : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 292)]
        public partial struct __Internal
        {
            internal fixed int max_quantizers[12];
            internal fixed int min_quantizers[12];
            internal fixed int scaling_factor_num[12];
            internal fixed int scaling_factor_den[12];
            internal fixed int speed_per_layer[12];
            internal int temporal_layering_mode;
            internal fixed int loopfilter_ctrl[12];

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_svc_parameters@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxSvcParameters> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxSvcParameters>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxSvcParameters managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxSvcParameters managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxSvcParameters __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxSvcParameters(native.ToPointer(), skipVTables);
        }

        internal static VpxSvcParameters __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxSvcParameters)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxSvcParameters __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxSvcParameters(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxSvcParameters(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxSvcParameters(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxSvcParameters()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxSvcParameters.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxSvcParameters(global::Vpx.VpxSvcParameters _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxSvcParameters.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxSvcParameters.__Internal*) __Instance) = *((global::Vpx.VpxSvcParameters.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Max Q for each layer</summary>
        public int[] MaxQuantizers
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->max_quantizers, 12);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 12; i++)
                        ((__Internal*)__Instance)->max_quantizers[i] = value[i];
                }
            }
        }

        /// <summary>Min Q for each layer</summary>
        public int[] MinQuantizers
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->min_quantizers, 12);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 12; i++)
                        ((__Internal*)__Instance)->min_quantizers[i] = value[i];
                }
            }
        }

        /// <summary>Scaling factor-numerator</summary>
        public int[] ScalingFactorNum
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->scaling_factor_num, 12);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 12; i++)
                        ((__Internal*)__Instance)->scaling_factor_num[i] = value[i];
                }
            }
        }

        /// <summary>Scaling factor-denominator</summary>
        public int[] ScalingFactorDen
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->scaling_factor_den, 12);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 12; i++)
                        ((__Internal*)__Instance)->scaling_factor_den[i] = value[i];
                }
            }
        }

        /// <summary>Speed setting for each sl</summary>
        public int[] SpeedPerLayer
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->speed_per_layer, 12);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 12; i++)
                        ((__Internal*)__Instance)->speed_per_layer[i] = value[i];
                }
            }
        }

        /// <summary>Temporal layering mode</summary>
        public int TemporalLayeringMode
        {
            get
            {
                return ((__Internal*)__Instance)->temporal_layering_mode;
            }

            set
            {
                ((__Internal*)__Instance)->temporal_layering_mode = value;
            }
        }

        /// <summary>Loopfilter ctrl for each sl</summary>
        public int[] LoopfilterCtrl
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->loopfilter_ctrl, 12);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 12; i++)
                        ((__Internal*)__Instance)->loopfilter_ctrl[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class vpx_encoder
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_enc_init_ver", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecEncInitVer(__IntPtr ctx, __IntPtr iface, __IntPtr cfg, int flags, int ver);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_enc_init_multi_ver", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecEncInitMultiVer(__IntPtr ctx, __IntPtr iface, __IntPtr cfg, int num_enc, int flags, __IntPtr dsf, int ver);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_enc_config_default", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecEncConfigDefault(__IntPtr iface, __IntPtr cfg, uint usage);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_enc_config_set", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecEncConfigSet(__IntPtr ctx, __IntPtr cfg);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_get_global_headers", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr VpxCodecGetGlobalHeaders(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_encode", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecEncode(__IntPtr ctx, __IntPtr img, long pts, uint duration, int flags, uint deadline);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_set_cx_data_buf", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecSetCxDataBuf(__IntPtr ctx, __IntPtr buf, uint pad_before, uint pad_after);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_get_cx_data", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr VpxCodecGetCxData(__IntPtr ctx, __IntPtr* iter);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_get_preview_frame", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr VpxCodecGetPreviewFrame(__IntPtr ctx);
        }

        /// <summary>Initialize an encoder instance</summary>
        /// <param name="ctx">Pointer to this instance's context.</param>
        /// <param name="iface">Pointer to the algorithm interface to use.</param>
        /// <param name="cfg">Configuration to use, if known. May be NULL.</param>
        /// <param name="flags">Bitfield of VPX_CODEC_USE_* flags</param>
        /// <param name="ver">
        /// <para>ABI version number. Must be set to</para>
        /// <para>VPX_ENCODER_ABI_VERSION</para>
        /// </param>
        /// <remarks>
        /// <para>Initializes an encoder context using the given interface. Applications</para>
        /// <para>should call the vpx_codec_enc_init convenience macro instead of this</para>
        /// <para>function directly, to ensure that the ABI version number parameter</para>
        /// <para>is properly initialized.</para>
        /// <para>If the library was configured with --disable-multithread, this call</para>
        /// <para>is not thread safe and should be guarded with a lock if being used</para>
        /// <para>in a multithreaded context.</para>
        /// <para>If vpx_codec_enc_init_ver() fails, it is not necessary to call</para>
        /// <para>vpx_codec_destroy() on the encoder context.</para>
        /// <para>The decoder algorithm initialized.</para>
        /// <para>Memory allocation failed.</para>
        /// </remarks>
        public static global::Vpx.VpxCodecErrT VpxCodecEncInitVer(global::Vpx.VpxCodecCtx ctx, global::Vpx.VpxCodecIface iface, global::Vpx.VpxCodecEncCfg cfg, int flags, int ver)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var __arg1 = iface is null ? __IntPtr.Zero : iface.__Instance;
            var __arg2 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            var ___ret = __Internal.VpxCodecEncInitVer(__arg0, __arg1, __arg2, flags, ver);
            return ___ret;
        }

        /// <summary>Initialize multi-encoder instance</summary>
        /// <param name="ctx">Pointer to this instance's context.</param>
        /// <param name="iface">Pointer to the algorithm interface to use.</param>
        /// <param name="cfg">Configuration to use, if known. May be NULL.</param>
        /// <param name="num_enc">Total number of encoders.</param>
        /// <param name="flags">Bitfield of VPX_CODEC_USE_* flags</param>
        /// <param name="dsf">Pointer to down-sampling factors.</param>
        /// <param name="ver">
        /// <para>ABI version number. Must be set to</para>
        /// <para>VPX_ENCODER_ABI_VERSION</para>
        /// </param>
        /// <remarks>
        /// <para>Initializes multi-encoder context using the given interface.</para>
        /// <para>Applications should call the vpx_codec_enc_init_multi convenience macro</para>
        /// <para>instead of this function directly, to ensure that the ABI version number</para>
        /// <para>parameter is properly initialized.</para>
        /// <para>The encoder algorithm has been initialized.</para>
        /// <para>Memory allocation failed.</para>
        /// </remarks>
        public static global::Vpx.VpxCodecErrT VpxCodecEncInitMultiVer(global::Vpx.VpxCodecCtx ctx, global::Vpx.VpxCodecIface iface, global::Vpx.VpxCodecEncCfg cfg, int num_enc, int flags, global::Vpx.VpxRational dsf, int ver)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var __arg1 = iface is null ? __IntPtr.Zero : iface.__Instance;
            var __arg2 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            var __arg5 = dsf is null ? __IntPtr.Zero : dsf.__Instance;
            var ___ret = __Internal.VpxCodecEncInitMultiVer(__arg0, __arg1, __arg2, num_enc, flags, __arg5, ver);
            return ___ret;
        }

        /// <summary>Get a default configuration</summary>
        /// <param name="iface">Pointer to the algorithm interface to use.</param>
        /// <param name="cfg">Configuration buffer to populate.</param>
        /// <param name="usage">Must be set to 0.</param>
        /// <remarks>
        /// <para>Initializes a encoder configuration structure with default values. Supports</para>
        /// <para>the notion of &quot;usages&quot; so that an algorithm may offer different default</para>
        /// <para>settings depending on the user's intended goal. This functionbe called by all applications to initialize the configuration structure</para>
        /// <para>before specializing the configuration with application specific values.</para>
        /// <para>The configuration was populated.</para>
        /// <para>Interface is not an encoder interface.</para>
        /// <para>A parameter was NULL, or the usage value was not recognized.</para>
        /// </remarks>
        public static global::Vpx.VpxCodecErrT VpxCodecEncConfigDefault(global::Vpx.VpxCodecIface iface, global::Vpx.VpxCodecEncCfg cfg, uint usage)
        {
            var __arg0 = iface is null ? __IntPtr.Zero : iface.__Instance;
            var __arg1 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            var ___ret = __Internal.VpxCodecEncConfigDefault(__arg0, __arg1, usage);
            return ___ret;
        }

        /// <summary>Set or change configuration</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="cfg">Configuration buffer to use</param>
        /// <remarks>
        /// <para>Reconfigures an encoder instance according to the given configuration.</para>
        /// <para>The configuration was populated.</para>
        /// <para>Interface is not an encoder interface.</para>
        /// <para>A parameter was NULL, or the usage value was not recognized.</para>
        /// </remarks>
        public static global::Vpx.VpxCodecErrT VpxCodecEncConfigSet(global::Vpx.VpxCodecCtx ctx, global::Vpx.VpxCodecEncCfg cfg)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var __arg1 = cfg is null ? __IntPtr.Zero : cfg.__Instance;
            var ___ret = __Internal.VpxCodecEncConfigSet(__arg0, __arg1);
            return ___ret;
        }

        /// <summary>Get global stream headers</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <remarks>
        /// <para>Retrieves a stream level global header packet, if supported by the codec.</para>
        /// <para>Encoder does not support global header</para>
        /// <para>Pointer to buffer containing global header packet</para>
        /// </remarks>
        public static global::Vpx.VpxFixedBuf VpxCodecGetGlobalHeaders(global::Vpx.VpxCodecCtx ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ___ret = __Internal.VpxCodecGetGlobalHeaders(__arg0);
            var __result0 = global::Vpx.VpxFixedBuf.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Encode a frame</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="img">Image data to encode, NULL to flush.</param>
        /// <param name="pts">Presentation time stamp, in timebase units.</param>
        /// <param name="duration">Duration to show frame, in timebase units.</param>
        /// <param name="flags">Flags to use for encoding this frame.</param>
        /// <param name="deadline">Time to spend encoding, in microseconds. (0=infinite)</param>
        /// <remarks>
        /// <para>Encodes a video frame at the given &quot;presentation time.&quot; The presentation</para>
        /// <para>time stamp (PTS)be strictly increasing.</para>
        /// <para>The encoder supports the notion of a soft real-time deadline. Given a</para>
        /// <para>non-zero value to the deadline parameter, the encoder will make a &quot;best</para>
        /// <para>effort&quot; guarantee to  return before the given time slice expires. It is</para>
        /// <para>implicit that limiting the available time to encode will degrade the</para>
        /// <para>output quality. The encoder can be given an unlimited time to produce the</para>
        /// <para>best possible frame by specifying a deadline of '0'. This deadline</para>
        /// <para>supersedes the VPx notion of &quot;best quality, good quality, realtime&quot;.</para>
        /// <para>Applications that wish to map these former settings to the new deadline</para>
        /// <para>based system can use the symbols #VPX_DL_REALTIME, #VPX_DL_GOOD_QUALITY,</para>
        /// <para>and #VPX_DL_BEST_QUALITY.</para>
        /// <para>When the last frame has been passed to the encoder, this function should</para>
        /// <para>continue to be called, with the img parameter set to NULL. This will</para>
        /// <para>signal the end-of-stream condition to the encoder and allow it to encode</para>
        /// <para>any held buffers. Encoding is complete when vpx_codec_encode() is called</para>
        /// <para>and vpx_codec_get_cx_data() returns no data.</para>
        /// <para>The configuration was populated.</para>
        /// <para>Interface is not an encoder interface.</para>
        /// <para>A parameter was NULL, the image format is unsupported, etc.</para>
        /// </remarks>
        public static global::Vpx.VpxCodecErrT VpxCodecEncode(global::Vpx.VpxCodecCtx ctx, global::Vpx.VpxImage img, long pts, uint duration, int flags, uint deadline)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var __arg1 = img is null ? __IntPtr.Zero : img.__Instance;
            var ___ret = __Internal.VpxCodecEncode(__arg0, __arg1, pts, duration, flags, deadline);
            return ___ret;
        }

        /// <summary>Set compressed data output buffer</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="buf">Buffer to store compressed data into</param>
        /// <param name="pad_before">Bytes to skip before writing compressed data</param>
        /// <param name="pad_after">Bytes to skip after writing compressed data</param>
        /// <remarks>
        /// <para>Sets the buffer that the codec should output the compressed data</para>
        /// <para>into. This call effectively sets the buffer pointer returned in the</para>
        /// <para>next VPX_CODEC_CX_FRAME_PKT packet. Subsequent packets will be</para>
        /// <para>appended into this buffer. The buffer is preserved across frames,</para>
        /// <para>so applications must periodically call this function after flushing</para>
        /// <para>the accumulated compressed data to disk or to the network to reset</para>
        /// <para>the pointer to the buffer's head.</para>
        /// <para>`pad_before` bytes will be skipped before writing the compressed</para>
        /// <para>data, and `pad_after` bytes will be appended to the packet. The size</para>
        /// <para>of the packet will be the sum of the size of the actual compressed</para>
        /// <para>data, pad_before, and pad_after. The padding bytes will be preserved</para>
        /// <para>(not overwritten).</para>
        /// <para>Note that calling this function does not guarantee that the returned</para>
        /// <para>compressed data will be placed into the specified buffer. In the</para>
        /// <para>event that the encoded data will not fit into the buffer provided,</para>
        /// <para>the returned packetpoint to an internal buffer, as it would</para>
        /// <para>if this call were never used. In this event, the output packet will</para>
        /// <para>NOT have any padding, and the application must free space and copy it</para>
        /// <para>to the proper place. This is of particular note in configurations</para>
        /// <para>that may output multiple packets for a single encoded frame (e.g., lagged</para>
        /// <para>encoding) or if the application does not reset the buffer periodically.</para>
        /// <para>Applications may restore the default behavior of the codec providing</para>
        /// <para>the compressed data buffer by calling this function with a NULL</para>
        /// <para>buffer.</para>
        /// <para>Applicationscall this function during iteration of</para>
        /// <para>vpx_codec_get_cx_data().</para>
        /// <para>The buffer was set successfully.</para>
        /// <para>A parameter was NULL, the image format is unsupported, etc.</para>
        /// </remarks>
        public static global::Vpx.VpxCodecErrT VpxCodecSetCxDataBuf(global::Vpx.VpxCodecCtx ctx, global::Vpx.VpxFixedBuf buf, uint pad_before, uint pad_after)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var __arg1 = buf is null ? __IntPtr.Zero : buf.__Instance;
            var ___ret = __Internal.VpxCodecSetCxDataBuf(__arg0, __arg1, pad_before, pad_after);
            return ___ret;
        }

        /// <summary>Encoded data iterator</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <param name="iter">Iterator storage, initialized to NULL</param>
        /// <returns>
        /// <para>Returns a pointer to an output data packet (compressed frame data,</para>
        /// <para>two-pass statistics, etc.) or NULL to signal end-of-list.</para>
        /// </returns>
        /// <remarks>
        /// <para>Iterates over a list of data packets to be passed from the encoder to the</para>
        /// <para>application. The different kinds of packets available are enumerated in</para>
        /// <para>#vpx_codec_cx_pkt_kind.</para>
        /// <para>#VPX_CODEC_CX_FRAME_PKT packets should be passed to the application's</para>
        /// <para>muxer. Multiple compressed frames may be in the list.</para>
        /// <para>#VPX_CODEC_STATS_PKT packets should be appended to a global buffer.</para>
        /// <para>The applicationsilently ignore any packet kinds that it does</para>
        /// <para>not recognize or support.</para>
        /// <para>The data buffers returned from this function are only guaranteed to be</para>
        /// <para>valid until the application makes another call to any vpx_codec_* function.</para>
        /// </remarks>
        public static global::Vpx.VpxCodecCxPkt VpxCodecGetCxData(global::Vpx.VpxCodecCtx ctx, __IntPtr* iter)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ___ret = __Internal.VpxCodecGetCxData(__arg0, iter);
            var __result0 = global::Vpx.VpxCodecCxPkt.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>Get Preview Frame</summary>
        /// <param name="ctx">Pointer to this instance's context</param>
        /// <returns>
        /// <para>Returns a pointer to a preview image, or NULL if no image is</para>
        /// <para>available.</para>
        /// </returns>
        /// <remarks>
        /// <para>Returns an image that can be used as a preview. Shows the image as it would</para>
        /// <para>exist at the decompressor. The applicationNOT write into this</para>
        /// <para>image buffer.</para>
        /// </remarks>
        public static global::Vpx.VpxImage VpxCodecGetPreviewFrame(global::Vpx.VpxCodecCtx ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var ___ret = __Internal.VpxCodecGetPreviewFrame(__arg0);
            var __result0 = global::Vpx.VpxImage.__GetOrCreateInstance(___ret, false);
            return __result0;
        }
    }

    /// <summary>
    /// <para>The control type of the inference API.</para>
    /// <para>In VPX_RC_QP mode, the external rate control model determines the</para>
    /// <para>quantization parameter (QP) for each frame.</para>
    /// <para>In VPX_RC_GOP mode, the external rate control model determines the</para>
    /// <para>group of picture (GOP) of the video sequence.</para>
    /// <para>In VPX_RC_RDMULT mode, the external rate control model determines the</para>
    /// <para>rate-distortion multiplier (rdmult) for the current frame.</para>
    /// <para>In VPX_RC_GOP_QP mode, the external rate control model determines</para>
    /// <para>both the QP and the GOP.</para>
    /// <para>In VPX_RC_GOP_QP_RDMULT mode, the external rate control model determines</para>
    /// <para>the QP, GOP and the rdmult.</para>
    /// </summary>
    public enum VpxRcType
    {
        VPX_RC_QP = 1,
        VPX_RC_GOP = 2,
        VPX_RC_RDMULT = 4,
        VPX_RC_GOP_QP = 3,
        VPX_RC_GOP_QP_RDMULT = 7
    }

    /// <summary>The rate control mode for the external rate control model.</summary>
    public enum VpxExtRcMode
    {
        VPX_RC_QMODE = 0,
        VPX_RC_VBR = 1,
        VPX_RC_CQ = 2
    }

    /// <summary>Status returned by rate control callback functions.</summary>
    public enum VpxRcStatus
    {
        VPX_RC_OK = 0,
        VPX_RC_ERROR = 1
    }

    /// <summary>
    /// <para>The control type of the inference API.</para>
    /// <para>In VPX_RC_QP mode, the external rate control model determines the</para>
    /// <para>quantization parameter (QP) for each frame.</para>
    /// <para>In VPX_RC_GOP mode, the external rate control model determines the</para>
    /// <para>group of picture (GOP) of the video sequence.</para>
    /// <para>In VPX_RC_RDMULT mode, the external rate control model determines the</para>
    /// <para>rate-distortion multiplier (rdmult) for the current frame.</para>
    /// <para>In VPX_RC_GOP_QP mode, the external rate control model determines</para>
    /// <para>both the QP and the GOP.</para>
    /// <para>In VPX_RC_GOP_QP_RDMULT mode, the external rate control model determines</para>
    /// <para>the QP, GOP and the rdmult.</para>
    /// </summary>
    /// <summary>The rate control mode for the external rate control model.</summary>
    /// <summary>Abstract rate control model handler</summary>
    /// <remarks>
    /// <para>The encoder will receive the model handler from create_model() defined in</para>
    /// <para>vpx_rc_funcs_t.</para>
    /// </remarks>
    /// <summary>Encode frame decision made by the external rate control model</summary>
    /// <remarks>
    /// <para>The encoder will receive the decision from the external rate control model</para>
    /// <para>through get_encodeframe_decision() defined in vpx_rc_funcs_t.</para>
    /// <para>If q_index = VPX_DEFAULT_Q, the encoder will use libvpx's default q.</para>
    /// <para>If max_frame_size = 0, the encoding ignores max frame size limit.</para>
    /// <para>If max_frame_size = -1, the encoding uses VP9's max frame size as the limit.</para>
    /// <para>If the encoded frame size is larger than max_frame_size, the frame is</para>
    /// <para>recoded to meet the size limit, following VP9's recoding principles.</para>
    /// </remarks>
    /// <summary>Information for the frame to be encoded.</summary>
    /// <remarks>
    /// <para>The encoder will send the information to external rate control model through</para>
    /// <para>get_encodeframe_decision() defined in vpx_rc_funcs_t.</para>
    /// </remarks>
    /// <summary>Frame coding result</summary>
    /// <remarks>
    /// <para>The encoder will send the result to the external rate control model through</para>
    /// <para>update_encodeframe_result() defined in vpx_rc_funcs_t.</para>
    /// </remarks>
    /// <summary>Status returned by rate control callback functions.</summary>
    /// <summary>
    /// <para>First pass frame stats</para>
    /// <para>This is a mirror of vp9's FIRSTPASS_STATS except that spatial_layer_id is</para>
    /// <para>omitted</para>
    /// </summary>
    /// <summary>Collection of first pass frame stats</summary>
    /// <summary>Encode config sent to external rate control model</summary>
    /// <summary>
    /// <para>Information passed to the external rate control model to</para>
    /// <para>help make GOP decisions.</para>
    /// </summary>
    /// <summary>
    /// <para>The decision made by the external rate control model to set the</para>
    /// <para>group of picture.</para>
    /// </summary>
    /// <summary>Create an external rate control model callback prototype</summary>
    /// <param name="priv">Callback's private data</param>
    /// <param name="ratectrl_config">Pointer to vpx_rc_config_t</param>
    /// <param name="rate_ctrl_model_ptr">Pointer to vpx_rc_model_t</param>
    /// <remarks>
    /// <para>This callback is invoked by the encoder to create an external rate control</para>
    /// <para>model.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::Vpx.VpxRcStatus VpxRcCreateModelCbFnT(__IntPtr priv, __IntPtr ratectrl_config, __IntPtr* rate_ctrl_model_ptr);

    /// <summary>
    /// <para>Send first pass stats to the external rate control model callback</para>
    /// <para>prototype</para>
    /// </summary>
    /// <param name="rate_ctrl_model">rate control model</param>
    /// <param name="first_pass_stats">first pass stats</param>
    /// <remarks>
    /// <para>This callback is invoked by the encoder to send first pass stats to the</para>
    /// <para>external rate control model.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::Vpx.VpxRcStatus VpxRcSendFirstpassStatsCbFnT(__IntPtr rate_ctrl_model, __IntPtr first_pass_stats);

    /// <summary>
    /// <para>Send TPL stats for the current GOP to the external rate control model</para>
    /// <para>callback prototype</para>
    /// </summary>
    /// <param name="rate_ctrl_model">rate control model</param>
    /// <param name="tpl_gop_stats">TPL stats for current GOP</param>
    /// <remarks>
    /// <para>This callback is invoked by the encoder to send TPL stats for the GOP to the</para>
    /// <para>external rate control model.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::Vpx.VpxRcStatus VpxRcSendTplGopStatsCbFnT(__IntPtr rate_ctrl_model, __IntPtr tpl_gop_stats);

    /// <summary>Receive encode frame decision callback prototype</summary>
    /// <param name="rate_ctrl_model">rate control model</param>
    /// <param name="encode_frame_info">information of the coding frame</param>
    /// <param name="frame_decision">encode decision of the coding frame</param>
    /// <remarks>
    /// <para>This callback is invoked by the encoder to receive encode frame decision from</para>
    /// <para>the external rate control model.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::Vpx.VpxRcStatus VpxRcGetEncodeframeDecisionCbFnT(__IntPtr rate_ctrl_model, __IntPtr encode_frame_info, __IntPtr frame_decision);

    /// <summary>Update encode frame result callback prototype</summary>
    /// <param name="rate_ctrl_model">rate control model</param>
    /// <param name="encode_frame_result">encode result of the coding frame</param>
    /// <remarks>
    /// <para>This callback is invoked by the encoder to update encode frame result to the</para>
    /// <para>external rate control model.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::Vpx.VpxRcStatus VpxRcUpdateEncodeframeResultCbFnT(__IntPtr rate_ctrl_model, __IntPtr encode_frame_result);

    /// <summary>Get the GOP structure from the external rate control model.</summary>
    /// <param name="rate_ctrl_model">rate control model</param>
    /// <param name="gop_info">information collected from the encoder</param>
    /// <param name="gop_decision">GOP decision from the model</param>
    /// <remarks>
    /// <para>This callback is invoked by the encoder to get GOP decisions from</para>
    /// <para>the external rate control model.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::Vpx.VpxRcStatus VpxRcGetGopDecisionCbFnT(__IntPtr rate_ctrl_model, __IntPtr gop_info, __IntPtr gop_decision);

    /// <summary>Get the frame rdmult from the external rate control model.</summary>
    /// <param name="rate_ctrl_model">rate control model</param>
    /// <param name="frame_info">information collected from the encoder</param>
    /// <param name="rdmult">frame rate-distortion multiplier from the model</param>
    /// <remarks>
    /// <para>This callback is invoked by the encoder to get rdmult from</para>
    /// <para>the external rate control model.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::Vpx.VpxRcStatus VpxRcGetFrameRdmultCbFnT(__IntPtr rate_ctrl_model, __IntPtr frame_info, int* rdmult);

    /// <summary>Delete the external rate control model callback prototype</summary>
    /// <param name="rate_ctrl_model">rate control model</param>
    /// <remarks>
    /// <para>This callback is invoked by the encoder to delete the external rate control</para>
    /// <para>model.</para>
    /// </remarks>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate global::Vpx.VpxRcStatus VpxRcDeleteModelCbFnT(__IntPtr rate_ctrl_model);

    /// <summary>Callback function set for external rate control.</summary>
    /// <remarks>
    /// <para>The user can enable external rate control by registering</para>
    /// <para>a set of callback functions with the codec control flag</para>
    /// <para>VP9E_SET_EXTERNAL_RATE_CONTROL.</para>
    /// </remarks>
    /// <summary>Encode frame decision made by the external rate control model</summary>
    /// <remarks>
    /// <para>The encoder will receive the decision from the external rate control model</para>
    /// <para>through get_encodeframe_decision() defined in vpx_rc_funcs_t.</para>
    /// <para>If q_index = VPX_DEFAULT_Q, the encoder will use libvpx's default q.</para>
    /// <para>If max_frame_size = 0, the encoding ignores max frame size limit.</para>
    /// <para>If max_frame_size = -1, the encoding uses VP9's max frame size as the limit.</para>
    /// <para>If the encoded frame size is larger than max_frame_size, the frame is</para>
    /// <para>recoded to meet the size limit, following VP9's recoding principles.</para>
    /// </remarks>
    public unsafe partial class VpxRcEncodeframeDecision : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal int q_index;
            internal int max_frame_size;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_rc_encodeframe_decision@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRcEncodeframeDecision> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRcEncodeframeDecision>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxRcEncodeframeDecision managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxRcEncodeframeDecision managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxRcEncodeframeDecision __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxRcEncodeframeDecision(native.ToPointer(), skipVTables);
        }

        internal static VpxRcEncodeframeDecision __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxRcEncodeframeDecision)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxRcEncodeframeDecision __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxRcEncodeframeDecision(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxRcEncodeframeDecision(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxRcEncodeframeDecision(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxRcEncodeframeDecision()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRcEncodeframeDecision.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxRcEncodeframeDecision(global::Vpx.VpxRcEncodeframeDecision _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRcEncodeframeDecision.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxRcEncodeframeDecision.__Internal*) __Instance) = *((global::Vpx.VpxRcEncodeframeDecision.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Quantizer step index [0..255]</summary>
        public int QIndex
        {
            get
            {
                return ((__Internal*)__Instance)->q_index;
            }

            set
            {
                ((__Internal*)__Instance)->q_index = value;
            }
        }

        /// <summary>Maximal frame size allowed to encode a frame</summary>
        public int MaxFrameSize
        {
            get
            {
                return ((__Internal*)__Instance)->max_frame_size;
            }

            set
            {
                ((__Internal*)__Instance)->max_frame_size = value;
            }
        }
    }

    /// <summary>Information for the frame to be encoded.</summary>
    /// <remarks>
    /// <para>The encoder will send the information to external rate control model through</para>
    /// <para>get_encodeframe_decision() defined in vpx_rc_funcs_t.</para>
    /// </remarks>
    public unsafe partial class VpxRcEncodeframeInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            internal int frame_type;
            internal int show_index;
            internal int coding_index;
            internal int gop_index;
            internal fixed int ref_frame_coding_indexes[3];
            internal fixed int ref_frame_valid_list[3];
            internal int gop_size;
            internal int use_alt_ref;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_rc_encodeframe_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRcEncodeframeInfo> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRcEncodeframeInfo>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxRcEncodeframeInfo managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxRcEncodeframeInfo managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxRcEncodeframeInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxRcEncodeframeInfo(native.ToPointer(), skipVTables);
        }

        internal static VpxRcEncodeframeInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxRcEncodeframeInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxRcEncodeframeInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxRcEncodeframeInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxRcEncodeframeInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxRcEncodeframeInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxRcEncodeframeInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRcEncodeframeInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxRcEncodeframeInfo(global::Vpx.VpxRcEncodeframeInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRcEncodeframeInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxRcEncodeframeInfo.__Internal*) __Instance) = *((global::Vpx.VpxRcEncodeframeInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>0: Key frame</para>
        /// <para>1: Inter frame</para>
        /// <para>2: Alternate reference frame</para>
        /// <para>3: Overlay frame</para>
        /// <para>4: Golden frame</para>
        /// </summary>
        public int FrameType
        {
            get
            {
                return ((__Internal*)__Instance)->frame_type;
            }

            set
            {
                ((__Internal*)__Instance)->frame_type = value;
            }
        }

        /// <summary>display index, starts from zero</summary>
        public int ShowIndex
        {
            get
            {
                return ((__Internal*)__Instance)->show_index;
            }

            set
            {
                ((__Internal*)__Instance)->show_index = value;
            }
        }

        /// <summary>coding index, starts from zero</summary>
        public int CodingIndex
        {
            get
            {
                return ((__Internal*)__Instance)->coding_index;
            }

            set
            {
                ((__Internal*)__Instance)->coding_index = value;
            }
        }

        /// <summary>index of the current frame in this group of picture, starts from zero.</summary>
        public int GopIndex
        {
            get
            {
                return ((__Internal*)__Instance)->gop_index;
            }

            set
            {
                ((__Internal*)__Instance)->gop_index = value;
            }
        }

        /// <summary>three reference frames' coding indices</summary>
        public int[] RefFrameCodingIndexes
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->ref_frame_coding_indexes, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->ref_frame_coding_indexes[i] = value[i];
                }
            }
        }

        /// <summary>
        /// <para>The validity of the three reference frames.</para>
        /// <para>0: Invalid</para>
        /// <para>1: Valid</para>
        /// </summary>
        public int[] RefFrameValidList
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->ref_frame_valid_list, 3);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 3; i++)
                        ((__Internal*)__Instance)->ref_frame_valid_list[i] = value[i];
                }
            }
        }

        /// <summary>The length of the current GOP.</summary>
        public int GopSize
        {
            get
            {
                return ((__Internal*)__Instance)->gop_size;
            }

            set
            {
                ((__Internal*)__Instance)->gop_size = value;
            }
        }

        /// <summary>Whether the current GOP uses an alt ref.</summary>
        public int UseAltRef
        {
            get
            {
                return ((__Internal*)__Instance)->use_alt_ref;
            }

            set
            {
                ((__Internal*)__Instance)->use_alt_ref = value;
            }
        }
    }

    /// <summary>Frame coding result</summary>
    /// <remarks>
    /// <para>The encoder will send the result to the external rate control model through</para>
    /// <para>update_encodeframe_result() defined in vpx_rc_funcs_t.</para>
    /// </remarks>
    public unsafe partial class VpxRcEncodeframeResult : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            internal long sse;
            internal long bit_count;
            internal long pixel_count;
            internal int actual_encoding_qindex;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_rc_encodeframe_result@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRcEncodeframeResult> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRcEncodeframeResult>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxRcEncodeframeResult managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxRcEncodeframeResult managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxRcEncodeframeResult __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxRcEncodeframeResult(native.ToPointer(), skipVTables);
        }

        internal static VpxRcEncodeframeResult __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxRcEncodeframeResult)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxRcEncodeframeResult __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxRcEncodeframeResult(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxRcEncodeframeResult(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxRcEncodeframeResult(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxRcEncodeframeResult()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRcEncodeframeResult.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxRcEncodeframeResult(global::Vpx.VpxRcEncodeframeResult _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRcEncodeframeResult.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxRcEncodeframeResult.__Internal*) __Instance) = *((global::Vpx.VpxRcEncodeframeResult.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>sum of squared error of the reconstructed frame</summary>
        public long Sse
        {
            get
            {
                return ((__Internal*)__Instance)->sse;
            }

            set
            {
                ((__Internal*)__Instance)->sse = value;
            }
        }

        /// <summary>number of bits spent on coding the frame</summary>
        public long BitCount
        {
            get
            {
                return ((__Internal*)__Instance)->bit_count;
            }

            set
            {
                ((__Internal*)__Instance)->bit_count = value;
            }
        }

        /// <summary>number of pixels in YUV planes of the frame</summary>
        public long PixelCount
        {
            get
            {
                return ((__Internal*)__Instance)->pixel_count;
            }

            set
            {
                ((__Internal*)__Instance)->pixel_count = value;
            }
        }

        /// <summary>the actual qindex used to encode the frame</summary>
        public int ActualEncodingQindex
        {
            get
            {
                return ((__Internal*)__Instance)->actual_encoding_qindex;
            }

            set
            {
                ((__Internal*)__Instance)->actual_encoding_qindex = value;
            }
        }
    }

    /// <summary>
    /// <para>First pass frame stats</para>
    /// <para>This is a mirror of vp9's FIRSTPASS_STATS except that spatial_layer_id is</para>
    /// <para>omitted</para>
    /// </summary>
    public unsafe partial class VpxRcFrameStats : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 208)]
        public partial struct __Internal
        {
            internal double frame;
            internal double weight;
            internal double intra_error;
            internal double coded_error;
            internal double sr_coded_error;
            internal double frame_noise_energy;
            internal double pcnt_inter;
            internal double pcnt_motion;
            internal double pcnt_second_ref;
            internal double pcnt_neutral;
            internal double pcnt_intra_low;
            internal double pcnt_intra_high;
            internal double intra_skip_pct;
            internal double intra_smooth_pct;
            internal double inactive_zone_rows;
            internal double inactive_zone_cols;
            internal double MVr;
            internal double mvr_abs;
            internal double MVc;
            internal double mvc_abs;
            internal double MVrv;
            internal double MVcv;
            internal double mv_in_out_count;
            internal double duration;
            internal double count;
            internal double new_mv_count;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_rc_frame_stats@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRcFrameStats> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRcFrameStats>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxRcFrameStats managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxRcFrameStats managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxRcFrameStats __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxRcFrameStats(native.ToPointer(), skipVTables);
        }

        internal static VpxRcFrameStats __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxRcFrameStats)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxRcFrameStats __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxRcFrameStats(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxRcFrameStats(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxRcFrameStats(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxRcFrameStats()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRcFrameStats.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxRcFrameStats(global::Vpx.VpxRcFrameStats _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRcFrameStats.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxRcFrameStats.__Internal*) __Instance) = *((global::Vpx.VpxRcFrameStats.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Frame number in display order, if stats are for a single frame.</para>
        /// <para>No real meaning for a collection of frames.</para>
        /// </summary>
        public double Frame
        {
            get
            {
                return ((__Internal*)__Instance)->frame;
            }

            set
            {
                ((__Internal*)__Instance)->frame = value;
            }
        }

        /// <summary>
        /// <para>Weight assigned to this frame (or total weight for the collection of</para>
        /// <para>frames) currently based on intra factor and brightness factor. This is used</para>
        /// <para>to distribute bits between easier and harder frames.</para>
        /// </summary>
        public double Weight
        {
            get
            {
                return ((__Internal*)__Instance)->weight;
            }

            set
            {
                ((__Internal*)__Instance)->weight = value;
            }
        }

        /// <summary>Intra prediction error.</summary>
        public double IntraError
        {
            get
            {
                return ((__Internal*)__Instance)->intra_error;
            }

            set
            {
                ((__Internal*)__Instance)->intra_error = value;
            }
        }

        /// <summary>Best of intra pred error and inter pred error using last frame as ref.</summary>
        public double CodedError
        {
            get
            {
                return ((__Internal*)__Instance)->coded_error;
            }

            set
            {
                ((__Internal*)__Instance)->coded_error = value;
            }
        }

        /// <summary>Best of intra pred error and inter pred error using golden frame as ref.</summary>
        public double SrCodedError
        {
            get
            {
                return ((__Internal*)__Instance)->sr_coded_error;
            }

            set
            {
                ((__Internal*)__Instance)->sr_coded_error = value;
            }
        }

        /// <summary>Estimate the noise energy of the current frame.</summary>
        public double FrameNoiseEnergy
        {
            get
            {
                return ((__Internal*)__Instance)->frame_noise_energy;
            }

            set
            {
                ((__Internal*)__Instance)->frame_noise_energy = value;
            }
        }

        /// <summary>Percentage of blocks with inter pred error&lt;intra pred error.</summary>
        public double PcntInter
        {
            get
            {
                return ((__Internal*)__Instance)->pcnt_inter;
            }

            set
            {
                ((__Internal*)__Instance)->pcnt_inter = value;
            }
        }

        /// <summary>Percentage of blocks using (inter prediction and) non-zero motion vectors.</summary>
        public double PcntMotion
        {
            get
            {
                return ((__Internal*)__Instance)->pcnt_motion;
            }

            set
            {
                ((__Internal*)__Instance)->pcnt_motion = value;
            }
        }

        /// <summary>
        /// <para>Percentage of blocks where golden frame was better than last or intra:</para>
        /// <para>inter pred error using golden frame&lt;inter pred error using last frame and</para>
        /// <para>inter pred error using golden frame&lt;intra pred error</para>
        /// </summary>
        public double PcntSecondRef
        {
            get
            {
                return ((__Internal*)__Instance)->pcnt_second_ref;
            }

            set
            {
                ((__Internal*)__Instance)->pcnt_second_ref = value;
            }
        }

        /// <summary>
        /// <para>Percentage of blocks where intra and inter prediction errors were very</para>
        /// <para>close.</para>
        /// </summary>
        public double PcntNeutral
        {
            get
            {
                return ((__Internal*)__Instance)->pcnt_neutral;
            }

            set
            {
                ((__Internal*)__Instance)->pcnt_neutral = value;
            }
        }

        /// <summary>
        /// <para>Percentage of blocks that have intra error&lt;inter error and inter error&lt;</para>
        /// <para>LOW_I_THRESH</para>
        /// <para>- bit_depth 8: LOW_I_THRESH = 24000</para>
        /// <para>- bit_depth 10: LOW_I_THRESH = 24000&lt;&lt;4</para>
        /// <para>- bit_depth 12: LOW_I_THRESH = 24000&lt;&lt;8</para>
        /// </summary>
        public double PcntIntraLow
        {
            get
            {
                return ((__Internal*)__Instance)->pcnt_intra_low;
            }

            set
            {
                ((__Internal*)__Instance)->pcnt_intra_low = value;
            }
        }

        /// <summary>
        /// <para>Percentage of blocks that have intra error&lt;inter error and intra error&lt;</para>
        /// <para>LOW_I_THRESH but inter error &gt;= LOW_I_THRESH LOW_I_THRESH</para>
        /// <para>- bit_depth 8: LOW_I_THRESH = 24000</para>
        /// <para>- bit_depth 10: LOW_I_THRESH = 24000&lt;&lt;4</para>
        /// <para>- bit_depth 12: LOW_I_THRESH = 24000&lt;&lt;8</para>
        /// </summary>
        public double PcntIntraHigh
        {
            get
            {
                return ((__Internal*)__Instance)->pcnt_intra_high;
            }

            set
            {
                ((__Internal*)__Instance)->pcnt_intra_high = value;
            }
        }

        /// <summary>
        /// <para>Percentage of blocks that have almost no intra error residual</para>
        /// <para>(i.e. are in effect completely flat and untextured in the intra</para>
        /// <para>domain). In natural videos this is uncommon, but it is much more</para>
        /// <para>common in animations, graphics and screen content, so may be used</para>
        /// <para>as a signal to detect these types of content.</para>
        /// </summary>
        public double IntraSkipPct
        {
            get
            {
                return ((__Internal*)__Instance)->intra_skip_pct;
            }

            set
            {
                ((__Internal*)__Instance)->intra_skip_pct = value;
            }
        }

        /// <summary>
        /// <para>Percentage of blocks that have intra error&lt;SMOOTH_INTRA_THRESH</para>
        /// <para>- bit_depth 8:  SMOOTH_INTRA_THRESH = 4000</para>
        /// <para>- bit_depth 10: SMOOTH_INTRA_THRESH = 4000&lt;&lt;4</para>
        /// <para>- bit_depth 12: SMOOTH_INTRA_THRESH = 4000&lt;&lt;8</para>
        /// </summary>
        public double IntraSmoothPct
        {
            get
            {
                return ((__Internal*)__Instance)->intra_smooth_pct;
            }

            set
            {
                ((__Internal*)__Instance)->intra_smooth_pct = value;
            }
        }

        /// <summary>Image mask rows top and bottom.</summary>
        public double InactiveZoneRows
        {
            get
            {
                return ((__Internal*)__Instance)->inactive_zone_rows;
            }

            set
            {
                ((__Internal*)__Instance)->inactive_zone_rows = value;
            }
        }

        /// <summary>Image mask columns at left and right edges.</summary>
        public double InactiveZoneCols
        {
            get
            {
                return ((__Internal*)__Instance)->inactive_zone_cols;
            }

            set
            {
                ((__Internal*)__Instance)->inactive_zone_cols = value;
            }
        }

        /// <summary>Mean of row motion vectors.</summary>
        public double MVr
        {
            get
            {
                return ((__Internal*)__Instance)->MVr;
            }

            set
            {
                ((__Internal*)__Instance)->MVr = value;
            }
        }

        /// <summary>Mean of absolute value of row motion vectors.</summary>
        public double MvrAbs
        {
            get
            {
                return ((__Internal*)__Instance)->mvr_abs;
            }

            set
            {
                ((__Internal*)__Instance)->mvr_abs = value;
            }
        }

        /// <summary>Mean of column motion vectors.</summary>
        public double MVc
        {
            get
            {
                return ((__Internal*)__Instance)->MVc;
            }

            set
            {
                ((__Internal*)__Instance)->MVc = value;
            }
        }

        /// <summary>Mean of absolute value of column motion vectors.</summary>
        public double MvcAbs
        {
            get
            {
                return ((__Internal*)__Instance)->mvc_abs;
            }

            set
            {
                ((__Internal*)__Instance)->mvc_abs = value;
            }
        }

        /// <summary>Variance of row motion vectors.</summary>
        public double MVrv
        {
            get
            {
                return ((__Internal*)__Instance)->MVrv;
            }

            set
            {
                ((__Internal*)__Instance)->MVrv = value;
            }
        }

        /// <summary>Variance of column motion vectors.</summary>
        public double MVcv
        {
            get
            {
                return ((__Internal*)__Instance)->MVcv;
            }

            set
            {
                ((__Internal*)__Instance)->MVcv = value;
            }
        }

        /// <summary>
        /// <para>Value in range [-1,1] indicating fraction of row and column motion vectors</para>
        /// <para>that point inwards (negative MV value) or outwards (positive MV value).</para>
        /// <para>For example, value of 1 indicates, all row/column MVs are inwards.</para>
        /// </summary>
        public double MvInOutCount
        {
            get
            {
                return ((__Internal*)__Instance)->mv_in_out_count;
            }

            set
            {
                ((__Internal*)__Instance)->mv_in_out_count = value;
            }
        }

        /// <summary>Duration of the frame / collection of frames.</summary>
        public double Duration
        {
            get
            {
                return ((__Internal*)__Instance)->duration;
            }

            set
            {
                ((__Internal*)__Instance)->duration = value;
            }
        }

        /// <summary>
        /// <para>1.0 if stats are for a single frame, or</para>
        /// <para>number of frames whose stats are accumulated.</para>
        /// </summary>
        public double Count
        {
            get
            {
                return ((__Internal*)__Instance)->count;
            }

            set
            {
                ((__Internal*)__Instance)->count = value;
            }
        }

        /// <summary>Number of new mv in a frame.</summary>
        public double NewMvCount
        {
            get
            {
                return ((__Internal*)__Instance)->new_mv_count;
            }

            set
            {
                ((__Internal*)__Instance)->new_mv_count = value;
            }
        }
    }

    /// <summary>Collection of first pass frame stats</summary>
    public unsafe partial class VpxRcFirstpassStats : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr frame_stats;
            internal int num_frames;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_rc_firstpass_stats@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRcFirstpassStats> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRcFirstpassStats>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxRcFirstpassStats managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxRcFirstpassStats managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxRcFirstpassStats __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxRcFirstpassStats(native.ToPointer(), skipVTables);
        }

        internal static VpxRcFirstpassStats __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxRcFirstpassStats)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxRcFirstpassStats __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxRcFirstpassStats(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxRcFirstpassStats(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxRcFirstpassStats(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxRcFirstpassStats()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRcFirstpassStats.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxRcFirstpassStats(global::Vpx.VpxRcFirstpassStats _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRcFirstpassStats.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxRcFirstpassStats.__Internal*) __Instance) = *((global::Vpx.VpxRcFirstpassStats.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Pointer to first pass frame stats.</para>
        /// <para>The pointed array of vpx_rc_frame_stats_t should have length equal to</para>
        /// <para>number of show frames in the video.</para>
        /// </summary>
        public global::Vpx.VpxRcFrameStats FrameStats
        {
            get
            {
                var __result0 = global::Vpx.VpxRcFrameStats.__GetOrCreateInstance(((__Internal*)__Instance)->frame_stats, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->frame_stats = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        /// <summary>Number of show frames in the video.</summary>
        public int NumFrames
        {
            get
            {
                return ((__Internal*)__Instance)->num_frames;
            }

            set
            {
                ((__Internal*)__Instance)->num_frames = value;
            }
        }
    }

    /// <summary>Encode config sent to external rate control model</summary>
    public unsafe partial class VpxRcConfig : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 44)]
        public partial struct __Internal
        {
            internal int frame_width;
            internal int frame_height;
            internal int show_frame_count;
            internal int max_gf_interval;
            internal int min_gf_interval;
            internal int target_bitrate_kbps;
            internal int frame_rate_num;
            internal int frame_rate_den;
            internal global::Vpx.VpxExtRcMode rc_mode;
            internal int overshoot_percent;
            internal int undershoot_percent;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_rc_config@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRcConfig> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRcConfig>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxRcConfig managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxRcConfig managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxRcConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxRcConfig(native.ToPointer(), skipVTables);
        }

        internal static VpxRcConfig __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxRcConfig)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxRcConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxRcConfig(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxRcConfig(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxRcConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxRcConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRcConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxRcConfig(global::Vpx.VpxRcConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRcConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxRcConfig.__Internal*) __Instance) = *((global::Vpx.VpxRcConfig.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>frame width</summary>
        public int FrameWidth
        {
            get
            {
                return ((__Internal*)__Instance)->frame_width;
            }

            set
            {
                ((__Internal*)__Instance)->frame_width = value;
            }
        }

        /// <summary>frame height</summary>
        public int FrameHeight
        {
            get
            {
                return ((__Internal*)__Instance)->frame_height;
            }

            set
            {
                ((__Internal*)__Instance)->frame_height = value;
            }
        }

        /// <summary>number of visible frames in the video</summary>
        public int ShowFrameCount
        {
            get
            {
                return ((__Internal*)__Instance)->show_frame_count;
            }

            set
            {
                ((__Internal*)__Instance)->show_frame_count = value;
            }
        }

        /// <summary>max GOP size in number of show frames</summary>
        public int MaxGfInterval
        {
            get
            {
                return ((__Internal*)__Instance)->max_gf_interval;
            }

            set
            {
                ((__Internal*)__Instance)->max_gf_interval = value;
            }
        }

        /// <summary>min GOP size in number of show frames</summary>
        public int MinGfInterval
        {
            get
            {
                return ((__Internal*)__Instance)->min_gf_interval;
            }

            set
            {
                ((__Internal*)__Instance)->min_gf_interval = value;
            }
        }

        /// <summary>Target bitrate in kilobytes per second</summary>
        public int TargetBitrateKbps
        {
            get
            {
                return ((__Internal*)__Instance)->target_bitrate_kbps;
            }

            set
            {
                ((__Internal*)__Instance)->target_bitrate_kbps = value;
            }
        }

        /// <summary>numerator of frame rate</summary>
        public int FrameRateNum
        {
            get
            {
                return ((__Internal*)__Instance)->frame_rate_num;
            }

            set
            {
                ((__Internal*)__Instance)->frame_rate_num = value;
            }
        }

        /// <summary>denominator of frame rate</summary>
        public int FrameRateDen
        {
            get
            {
                return ((__Internal*)__Instance)->frame_rate_den;
            }

            set
            {
                ((__Internal*)__Instance)->frame_rate_den = value;
            }
        }

        /// <summary>Q mode or VBR mode</summary>
        public global::Vpx.VpxExtRcMode RcMode
        {
            get
            {
                return ((__Internal*)__Instance)->rc_mode;
            }

            set
            {
                ((__Internal*)__Instance)->rc_mode = value;
            }
        }

        /// <summary>for VBR mode only</summary>
        public int OvershootPercent
        {
            get
            {
                return ((__Internal*)__Instance)->overshoot_percent;
            }

            set
            {
                ((__Internal*)__Instance)->overshoot_percent = value;
            }
        }

        /// <summary>for VBR mode only</summary>
        public int UndershootPercent
        {
            get
            {
                return ((__Internal*)__Instance)->undershoot_percent;
            }

            set
            {
                ((__Internal*)__Instance)->undershoot_percent = value;
            }
        }
    }

    /// <summary>
    /// <para>Information passed to the external rate control model to</para>
    /// <para>help make GOP decisions.</para>
    /// </summary>
    public unsafe partial class VpxRcGopInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 52)]
        public partial struct __Internal
        {
            internal int min_gf_interval;
            internal int max_gf_interval;
            internal int active_min_gf_interval;
            internal int active_max_gf_interval;
            internal int allow_alt_ref;
            internal int is_key_frame;
            internal int last_gop_use_alt_ref;
            internal int frames_since_key;
            internal int frames_to_key;
            internal int lag_in_frames;
            internal int show_index;
            internal int coding_index;
            internal int gop_global_index;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_rc_gop_info@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRcGopInfo> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRcGopInfo>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxRcGopInfo managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxRcGopInfo managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxRcGopInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxRcGopInfo(native.ToPointer(), skipVTables);
        }

        internal static VpxRcGopInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxRcGopInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxRcGopInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxRcGopInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxRcGopInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxRcGopInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxRcGopInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRcGopInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxRcGopInfo(global::Vpx.VpxRcGopInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRcGopInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxRcGopInfo.__Internal*) __Instance) = *((global::Vpx.VpxRcGopInfo.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>Minimum allowed gf interval, fixed for the whole clip.</para>
        /// <para>Note that it will be modified to match vp9's level constraints</para>
        /// <para>in the encoder.</para>
        /// <para>The level constraint is defined in vp9_encoder.c:</para>
        /// <para>const Vp9LevelSpec vp9_level_defs[VP9_LEVELS].</para>
        /// </summary>
        public int MinGfInterval
        {
            get
            {
                return ((__Internal*)__Instance)->min_gf_interval;
            }

            set
            {
                ((__Internal*)__Instance)->min_gf_interval = value;
            }
        }

        /// <summary>Maximum allowed gf interval, fixed for the whole clip.</summary>
        public int MaxGfInterval
        {
            get
            {
                return ((__Internal*)__Instance)->max_gf_interval;
            }

            set
            {
                ((__Internal*)__Instance)->max_gf_interval = value;
            }
        }

        /// <summary>
        /// <para>Minimum allowed gf interval for the current GOP, determined</para>
        /// <para>by the encoder.</para>
        /// </summary>
        public int ActiveMinGfInterval
        {
            get
            {
                return ((__Internal*)__Instance)->active_min_gf_interval;
            }

            set
            {
                ((__Internal*)__Instance)->active_min_gf_interval = value;
            }
        }

        /// <summary>
        /// <para>Maximum allowed gf interval for the current GOP, determined</para>
        /// <para>by the encoder.</para>
        /// </summary>
        public int ActiveMaxGfInterval
        {
            get
            {
                return ((__Internal*)__Instance)->active_max_gf_interval;
            }

            set
            {
                ((__Internal*)__Instance)->active_max_gf_interval = value;
            }
        }

        /// <summary>
        /// <para>Whether to allow the use of alt ref, determined by the encoder.</para>
        /// <para>It is fixed for the entire encode.</para>
        /// <para>See function &quot;is_altref_enabled&quot; in vp9_encoder.h.</para>
        /// </summary>
        public int AllowAltRef
        {
            get
            {
                return ((__Internal*)__Instance)->allow_alt_ref;
            }

            set
            {
                ((__Internal*)__Instance)->allow_alt_ref = value;
            }
        }

        /// <summary>Is the current frame a key frame.</summary>
        public int IsKeyFrame
        {
            get
            {
                return ((__Internal*)__Instance)->is_key_frame;
            }

            set
            {
                ((__Internal*)__Instance)->is_key_frame = value;
            }
        }

        /// <summary>Does the previous gop use alt ref or not.</summary>
        public int LastGopUseAltRef
        {
            get
            {
                return ((__Internal*)__Instance)->last_gop_use_alt_ref;
            }

            set
            {
                ((__Internal*)__Instance)->last_gop_use_alt_ref = value;
            }
        }

        /// <summary>
        /// <para>Current frame distance to the last keyframe, e.g., if Nth frame is a key,</para>
        /// <para>then the value of the N+1 th frame is 1.</para>
        /// </summary>
        public int FramesSinceKey
        {
            get
            {
                return ((__Internal*)__Instance)->frames_since_key;
            }

            set
            {
                ((__Internal*)__Instance)->frames_since_key = value;
            }
        }

        /// <summary>
        /// <para>Current frame distance to the next keyframe, e.g. if Nth frame is a key,</para>
        /// <para>then the value of frame N - 1 is 1.</para>
        /// </summary>
        public int FramesToKey
        {
            get
            {
                return ((__Internal*)__Instance)->frames_to_key;
            }

            set
            {
                ((__Internal*)__Instance)->frames_to_key = value;
            }
        }

        /// <summary>Number of lookahead source frames.</summary>
        public int LagInFrames
        {
            get
            {
                return ((__Internal*)__Instance)->lag_in_frames;
            }

            set
            {
                ((__Internal*)__Instance)->lag_in_frames = value;
            }
        }

        /// <summary>
        /// <para>Display index (temporal stamp) of this frame in the whole clip,</para>
        /// <para>starts from zero.</para>
        /// </summary>
        public int ShowIndex
        {
            get
            {
                return ((__Internal*)__Instance)->show_index;
            }

            set
            {
                ((__Internal*)__Instance)->show_index = value;
            }
        }

        /// <summary>Coding index of this frame in the whole clip, starts from zero.</summary>
        public int CodingIndex
        {
            get
            {
                return ((__Internal*)__Instance)->coding_index;
            }

            set
            {
                ((__Internal*)__Instance)->coding_index = value;
            }
        }

        /// <summary>
        /// <para>The index of the current gop, starts from zero, resets to zero</para>
        /// <para>when a keyframe is set.</para>
        /// </summary>
        public int GopGlobalIndex
        {
            get
            {
                return ((__Internal*)__Instance)->gop_global_index;
            }

            set
            {
                ((__Internal*)__Instance)->gop_global_index = value;
            }
        }
    }

    /// <summary>
    /// <para>The decision made by the external rate control model to set the</para>
    /// <para>group of picture.</para>
    /// </summary>
    public unsafe partial class VpxRcGopDecision : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal int gop_coding_frames;
            internal int use_alt_ref;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_rc_gop_decision@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRcGopDecision> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRcGopDecision>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxRcGopDecision managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxRcGopDecision managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxRcGopDecision __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxRcGopDecision(native.ToPointer(), skipVTables);
        }

        internal static VpxRcGopDecision __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxRcGopDecision)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxRcGopDecision __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxRcGopDecision(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxRcGopDecision(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxRcGopDecision(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxRcGopDecision()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRcGopDecision.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxRcGopDecision(global::Vpx.VpxRcGopDecision _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRcGopDecision.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxRcGopDecision.__Internal*) __Instance) = *((global::Vpx.VpxRcGopDecision.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The number of frames of this GOP</summary>
        public int GopCodingFrames
        {
            get
            {
                return ((__Internal*)__Instance)->gop_coding_frames;
            }

            set
            {
                ((__Internal*)__Instance)->gop_coding_frames = value;
            }
        }

        /// <summary>Whether to use alt ref for this GOP</summary>
        public int UseAltRef
        {
            get
            {
                return ((__Internal*)__Instance)->use_alt_ref;
            }

            set
            {
                ((__Internal*)__Instance)->use_alt_ref = value;
            }
        }
    }

    /// <summary>Callback function set for external rate control.</summary>
    /// <remarks>
    /// <para>The user can enable external rate control by registering</para>
    /// <para>a set of callback functions with the codec control flag</para>
    /// <para>VP9E_SET_EXTERNAL_RATE_CONTROL.</para>
    /// </remarks>
    public unsafe partial class VpxRcFuncs : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 80)]
        public partial struct __Internal
        {
            internal global::Vpx.VpxRcType rc_type;
            internal __IntPtr create_model;
            internal __IntPtr send_firstpass_stats;
            internal __IntPtr send_tpl_gop_stats;
            internal __IntPtr get_encodeframe_decision;
            internal __IntPtr update_encodeframe_result;
            internal __IntPtr get_gop_decision;
            internal __IntPtr get_frame_rdmult;
            internal __IntPtr delete_model;
            internal __IntPtr priv;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_rc_funcs@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRcFuncs> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRcFuncs>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxRcFuncs managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxRcFuncs managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxRcFuncs __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxRcFuncs(native.ToPointer(), skipVTables);
        }

        internal static VpxRcFuncs __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxRcFuncs)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxRcFuncs __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxRcFuncs(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxRcFuncs(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxRcFuncs(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxRcFuncs()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRcFuncs.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxRcFuncs(global::Vpx.VpxRcFuncs _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRcFuncs.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxRcFuncs.__Internal*) __Instance) = *((global::Vpx.VpxRcFuncs.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>The rate control type of this API.</summary>
        public global::Vpx.VpxRcType RcType
        {
            get
            {
                return ((__Internal*)__Instance)->rc_type;
            }

            set
            {
                ((__Internal*)__Instance)->rc_type = value;
            }
        }

        /// <summary>Create an external rate control model.</summary>
        public global::Vpx.VpxRcCreateModelCbFnT CreateModel
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->create_model;
                return __ptr0 == IntPtr.Zero? null : (global::Vpx.VpxRcCreateModelCbFnT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Vpx.VpxRcCreateModelCbFnT));
            }

            set
            {
                ((__Internal*)__Instance)->create_model = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Send first pass stats to the external rate control model.</summary>
        public global::Vpx.VpxRcSendFirstpassStatsCbFnT SendFirstpassStats
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->send_firstpass_stats;
                return __ptr0 == IntPtr.Zero? null : (global::Vpx.VpxRcSendFirstpassStatsCbFnT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Vpx.VpxRcSendFirstpassStatsCbFnT));
            }

            set
            {
                ((__Internal*)__Instance)->send_firstpass_stats = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Send TPL stats for current GOP to the external rate control model.</summary>
        public global::Vpx.VpxRcSendTplGopStatsCbFnT SendTplGopStats
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->send_tpl_gop_stats;
                return __ptr0 == IntPtr.Zero? null : (global::Vpx.VpxRcSendTplGopStatsCbFnT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Vpx.VpxRcSendTplGopStatsCbFnT));
            }

            set
            {
                ((__Internal*)__Instance)->send_tpl_gop_stats = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Get encodeframe decision from the external rate control model.</summary>
        public global::Vpx.VpxRcGetEncodeframeDecisionCbFnT GetEncodeframeDecision
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_encodeframe_decision;
                return __ptr0 == IntPtr.Zero? null : (global::Vpx.VpxRcGetEncodeframeDecisionCbFnT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Vpx.VpxRcGetEncodeframeDecisionCbFnT));
            }

            set
            {
                ((__Internal*)__Instance)->get_encodeframe_decision = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Update encodeframe result to the external rate control model.</summary>
        public global::Vpx.VpxRcUpdateEncodeframeResultCbFnT UpdateEncodeframeResult
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->update_encodeframe_result;
                return __ptr0 == IntPtr.Zero? null : (global::Vpx.VpxRcUpdateEncodeframeResultCbFnT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Vpx.VpxRcUpdateEncodeframeResultCbFnT));
            }

            set
            {
                ((__Internal*)__Instance)->update_encodeframe_result = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Get GOP decisions from the external rate control model.</summary>
        public global::Vpx.VpxRcGetGopDecisionCbFnT GetGopDecision
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_gop_decision;
                return __ptr0 == IntPtr.Zero? null : (global::Vpx.VpxRcGetGopDecisionCbFnT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Vpx.VpxRcGetGopDecisionCbFnT));
            }

            set
            {
                ((__Internal*)__Instance)->get_gop_decision = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Get rdmult for the frame from the external rate control model.</summary>
        public global::Vpx.VpxRcGetFrameRdmultCbFnT GetFrameRdmult
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->get_frame_rdmult;
                return __ptr0 == IntPtr.Zero? null : (global::Vpx.VpxRcGetFrameRdmultCbFnT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Vpx.VpxRcGetFrameRdmultCbFnT));
            }

            set
            {
                ((__Internal*)__Instance)->get_frame_rdmult = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Delete the external rate control model.</summary>
        public global::Vpx.VpxRcDeleteModelCbFnT DeleteModel
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->delete_model;
                return __ptr0 == IntPtr.Zero? null : (global::Vpx.VpxRcDeleteModelCbFnT) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Vpx.VpxRcDeleteModelCbFnT));
            }

            set
            {
                ((__Internal*)__Instance)->delete_model = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Private data for the external rate control model.</summary>
        public __IntPtr Priv
        {
            get
            {
                return ((__Internal*)__Instance)->priv;
            }

            set
            {
                ((__Internal*)__Instance)->priv = (__IntPtr) value;
            }
        }
    }

    /// <summary>Temporal dependency model stats for each block before propagation</summary>
    /// <summary>Temporal dependency model stats for each frame before propagation</summary>
    /// <summary>Temporal dependency model stats for each GOP before propagation</summary>
    /// <summary>Temporal dependency model stats for each block before propagation</summary>
    public unsafe partial class VpxTplBlockStats : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            internal short row;
            internal short col;
            internal long intra_cost;
            internal long inter_cost;
            internal short mv_r;
            internal short mv_c;
            internal long recrf_rate;
            internal long recrf_dist;
            internal int ref_frame_index;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0VpxTplBlockStats@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxTplBlockStats> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxTplBlockStats>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxTplBlockStats managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxTplBlockStats managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxTplBlockStats __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxTplBlockStats(native.ToPointer(), skipVTables);
        }

        internal static VpxTplBlockStats __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxTplBlockStats)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxTplBlockStats __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxTplBlockStats(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxTplBlockStats(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxTplBlockStats(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxTplBlockStats()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxTplBlockStats.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxTplBlockStats(global::Vpx.VpxTplBlockStats _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxTplBlockStats.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxTplBlockStats.__Internal*) __Instance) = *((global::Vpx.VpxTplBlockStats.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Pixel row of the top left corner</summary>
        public short Row
        {
            get
            {
                return ((__Internal*)__Instance)->row;
            }

            set
            {
                ((__Internal*)__Instance)->row = value;
            }
        }

        /// <summary>Pixel col of the top left corner</summary>
        public short Col
        {
            get
            {
                return ((__Internal*)__Instance)->col;
            }

            set
            {
                ((__Internal*)__Instance)->col = value;
            }
        }

        /// <summary>Intra cost</summary>
        public long IntraCost
        {
            get
            {
                return ((__Internal*)__Instance)->intra_cost;
            }

            set
            {
                ((__Internal*)__Instance)->intra_cost = value;
            }
        }

        /// <summary>Inter cost</summary>
        public long InterCost
        {
            get
            {
                return ((__Internal*)__Instance)->inter_cost;
            }

            set
            {
                ((__Internal*)__Instance)->inter_cost = value;
            }
        }

        /// <summary>Motion vector row</summary>
        public short MvR
        {
            get
            {
                return ((__Internal*)__Instance)->mv_r;
            }

            set
            {
                ((__Internal*)__Instance)->mv_r = value;
            }
        }

        /// <summary>Motion vector col</summary>
        public short MvC
        {
            get
            {
                return ((__Internal*)__Instance)->mv_c;
            }

            set
            {
                ((__Internal*)__Instance)->mv_c = value;
            }
        }

        /// <summary>Rate from reconstructed ref frame</summary>
        public long RecrfRate
        {
            get
            {
                return ((__Internal*)__Instance)->recrf_rate;
            }

            set
            {
                ((__Internal*)__Instance)->recrf_rate = value;
            }
        }

        /// <summary>Distortion from reconstructed ref frame</summary>
        public long RecrfDist
        {
            get
            {
                return ((__Internal*)__Instance)->recrf_dist;
            }

            set
            {
                ((__Internal*)__Instance)->recrf_dist = value;
            }
        }

        /// <summary>Ref frame index in the ref frame buffer</summary>
        public int RefFrameIndex
        {
            get
            {
                return ((__Internal*)__Instance)->ref_frame_index;
            }

            set
            {
                ((__Internal*)__Instance)->ref_frame_index = value;
            }
        }
    }

    /// <summary>Temporal dependency model stats for each frame before propagation</summary>
    public unsafe partial class VpxTplFrameStats : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal int frame_width;
            internal int frame_height;
            internal int num_blocks;
            internal __IntPtr block_stats_list;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0VpxTplFrameStats@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxTplFrameStats> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxTplFrameStats>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxTplFrameStats managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxTplFrameStats managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxTplFrameStats __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxTplFrameStats(native.ToPointer(), skipVTables);
        }

        internal static VpxTplFrameStats __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxTplFrameStats)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxTplFrameStats __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxTplFrameStats(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxTplFrameStats(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxTplFrameStats(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxTplFrameStats()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxTplFrameStats.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxTplFrameStats(global::Vpx.VpxTplFrameStats _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxTplFrameStats.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxTplFrameStats.__Internal*) __Instance) = *((global::Vpx.VpxTplFrameStats.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Frame width</summary>
        public int FrameWidth
        {
            get
            {
                return ((__Internal*)__Instance)->frame_width;
            }

            set
            {
                ((__Internal*)__Instance)->frame_width = value;
            }
        }

        /// <summary>Frame height</summary>
        public int FrameHeight
        {
            get
            {
                return ((__Internal*)__Instance)->frame_height;
            }

            set
            {
                ((__Internal*)__Instance)->frame_height = value;
            }
        }

        /// <summary>Number of blocks. Size of block_stats_list</summary>
        public int NumBlocks
        {
            get
            {
                return ((__Internal*)__Instance)->num_blocks;
            }

            set
            {
                ((__Internal*)__Instance)->num_blocks = value;
            }
        }

        /// <summary>List of tpl stats for each block</summary>
        public global::Vpx.VpxTplBlockStats BlockStatsList
        {
            get
            {
                var __result0 = global::Vpx.VpxTplBlockStats.__GetOrCreateInstance(((__Internal*)__Instance)->block_stats_list, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->block_stats_list = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    /// <summary>Temporal dependency model stats for each GOP before propagation</summary>
    public unsafe partial class VpxTplGopStats : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal int size;
            internal __IntPtr frame_stats_list;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0VpxTplGopStats@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxTplGopStats> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxTplGopStats>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxTplGopStats managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxTplGopStats managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxTplGopStats __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxTplGopStats(native.ToPointer(), skipVTables);
        }

        internal static VpxTplGopStats __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxTplGopStats)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxTplGopStats __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxTplGopStats(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxTplGopStats(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxTplGopStats(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxTplGopStats()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxTplGopStats.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxTplGopStats(global::Vpx.VpxTplGopStats _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxTplGopStats.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxTplGopStats.__Internal*) __Instance) = *((global::Vpx.VpxTplGopStats.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>GOP size, also the size of frame_stats_list.</summary>
        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->size;
            }

            set
            {
                ((__Internal*)__Instance)->size = value;
            }
        }

        /// <summary>List of tpl stats for each frame</summary>
        public global::Vpx.VpxTplFrameStats FrameStatsList
        {
            get
            {
                var __result0 = global::Vpx.VpxTplFrameStats.__GetOrCreateInstance(((__Internal*)__Instance)->frame_stats_list, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->frame_stats_list = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class vpx_tpl
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_write_tpl_gop_stats", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxWriteTplGopStats(__IntPtr tpl_file, __IntPtr tpl_gop_stats);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_read_tpl_gop_stats", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxReadTplGopStats(__IntPtr tpl_file, __IntPtr tpl_gop_stats);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_free_tpl_gop_stats", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void VpxFreeTplGopStats(__IntPtr tpl_gop_stats);
        }

        /// <summary>Write VpxTplGopStats to file</summary>
        /// <param name="tpl_file">A FILE pointer that's already been opened.</param>
        /// <param name="tpl_gop_stats">
        /// <para>VpxTplGopStats that contains TPL stats for the</para>
        /// <para>whole GOP.</para>
        /// </param>
        /// <returns>VPX_CODEC_OK if TPL stats are successfully written.</returns>
        /// <remarks>Accepts an opened file handle and writes</remarks>
        public static global::Vpx.VpxCodecErrT VpxWriteTplGopStats(global::System.IntPtr tpl_file, global::Vpx.VpxTplGopStats tpl_gop_stats)
        {
            var __arg1 = tpl_gop_stats is null ? __IntPtr.Zero : tpl_gop_stats.__Instance;
            var ___ret = __Internal.VpxWriteTplGopStats(tpl_file, __arg1);
            return ___ret;
        }

        /// <summary>Read VpxTplGopStats from file</summary>
        /// <param name="tpl_file">A FILE pointer that's already been opened.</param>
        /// <param name="tpl_gop_stats">
        /// <para>VpxTplGopStats that contains TPL stats for the</para>
        /// <para>whole GOP.</para>
        /// </param>
        /// <returns>VPX_CODEC_OK if TPL stats are successfully read from file.</returns>
        /// <remarks>
        /// <para>Accepts an opened file handle and reads TPL stats and stores them into</para>
        /// <para>Allocates memory for TPL stats.</para>
        /// </remarks>
        public static global::Vpx.VpxCodecErrT VpxReadTplGopStats(global::System.IntPtr tpl_file, global::Vpx.VpxTplGopStats tpl_gop_stats)
        {
            var __arg1 = tpl_gop_stats is null ? __IntPtr.Zero : tpl_gop_stats.__Instance;
            var ___ret = __Internal.VpxReadTplGopStats(tpl_file, __arg1);
            return ___ret;
        }

        /// <summary>Free the memory allocated for VpxTplGopStats</summary>
        /// <param name="tpl_gop_stats">
        /// <para>VpxTplGopStats that contains TPL stats for the</para>
        /// <para>whole GOP.</para>
        /// </param>
        public static void VpxFreeTplGopStats(global::Vpx.VpxTplGopStats tpl_gop_stats)
        {
            var __arg0 = tpl_gop_stats is null ? __IntPtr.Zero : tpl_gop_stats.__Instance;
            __Internal.VpxFreeTplGopStats(__arg0);
        }
    }

    /// <summary>Control functions</summary>
    /// <remarks>The set of macros define the control functions of VP8 interface</remarks>
    public enum Vp8ComControlId
    {
        /// <summary>pass in an external frame into decoder to be used as reference frame</summary>
        VP8SET_REFERENCE = 1,
        /// <summary>get a copy of reference frame from the decoder</summary>
        VP8COPY_REFERENCE = 2,
        /// <summary>set the decoder's post processing settings</summary>
        VP8SET_POSTPROC = 3,
        /// <summary>get a pointer to a reference frame</summary>
        VP9GET_REFERENCE = 128,
        VP8COMMON_CTRL_ID_MAX = 129,
        VP8DECODER_CTRL_ID_START = 256
    }

    /// <summary>post process flags</summary>
    /// <remarks>The set of macros define VP8 decoder post processing flags</remarks>
    [Flags]
    public enum Vp8PostprocLevel
    {
        VP8NOFILTERING = 0,
        VP8DEBLOCK = 1,
        VP8DEMACROBLOCK = 2,
        VP8ADDNOISE = 4,
        VP8MFQE = 8
    }

    /// <summary>reference frame type</summary>
    /// <remarks>The set of macros define the type of VP8 reference frames</remarks>
    [Flags]
    public enum VpxRefFrameType
    {
        VP8LAST_FRAME = 1,
        VP8GOLD_FRAME = 2,
        VP8ALTR_FRAME = 4
    }

    /// <summary>post process flags</summary>
    /// <remarks>
    /// <para>This define a structure that describe the post processing settings. For</para>
    /// <para>the best objective measure (using the PSNR metric) set post_proc_flag</para>
    /// <para>to VP8_DEBLOCK and deblocking_level to 1.</para>
    /// </remarks>
    /// <summary>reference frame type</summary>
    /// <remarks>The set of macros define the type of VP8 reference frames</remarks>
    /// <summary>reference frame data struct</summary>
    /// <remarks>Define the data struct to access vp8 reference frames.</remarks>
    /// <summary>VP9 specific reference frame data struct</summary>
    /// <remarks>Define the data struct to access vp9 reference frames.</remarks>
    /// <summary>post process flags</summary>
    /// <remarks>
    /// <para>This define a structure that describe the post processing settings. For</para>
    /// <para>the best objective measure (using the PSNR metric) set post_proc_flag</para>
    /// <para>to VP8_DEBLOCK and deblocking_level to 1.</para>
    /// </remarks>
    public unsafe partial class Vp8PostprocCfg : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            internal int post_proc_flag;
            internal int deblocking_level;
            internal int noise_level;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vp8_postproc_cfg@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.Vp8PostprocCfg> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.Vp8PostprocCfg>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.Vp8PostprocCfg managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.Vp8PostprocCfg managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Vp8PostprocCfg __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Vp8PostprocCfg(native.ToPointer(), skipVTables);
        }

        internal static Vp8PostprocCfg __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Vp8PostprocCfg)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Vp8PostprocCfg __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Vp8PostprocCfg(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Vp8PostprocCfg(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Vp8PostprocCfg(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Vp8PostprocCfg()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.Vp8PostprocCfg.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public Vp8PostprocCfg(global::Vpx.Vp8PostprocCfg _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.Vp8PostprocCfg.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.Vp8PostprocCfg.__Internal*) __Instance) = *((global::Vpx.Vp8PostprocCfg.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>
        /// <para>the types of post processing to be done, should be combination of</para>
        /// <para>&quot;vp8_postproc_level&quot;</para>
        /// </summary>
        public int PostProcFlag
        {
            get
            {
                return ((__Internal*)__Instance)->post_proc_flag;
            }

            set
            {
                ((__Internal*)__Instance)->post_proc_flag = value;
            }
        }

        /// <summary>the strength of deblocking, valid range [0, 16]</summary>
        public int DeblockingLevel
        {
            get
            {
                return ((__Internal*)__Instance)->deblocking_level;
            }

            set
            {
                ((__Internal*)__Instance)->deblocking_level = value;
            }
        }

        /// <summary>the strength of additive noise, valid range [0, 16]</summary>
        public int NoiseLevel
        {
            get
            {
                return ((__Internal*)__Instance)->noise_level;
            }

            set
            {
                ((__Internal*)__Instance)->noise_level = value;
            }
        }
    }

    /// <summary>reference frame data struct</summary>
    /// <remarks>Define the data struct to access vp8 reference frames.</remarks>
    public unsafe partial class VpxRefFrame : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 144)]
        public partial struct __Internal
        {
            internal global::Vpx.VpxRefFrameType frame_type;
            internal global::Vpx.VpxImage.__Internal img;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_ref_frame@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRefFrame> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRefFrame>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxRefFrame managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxRefFrame managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxRefFrame __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxRefFrame(native.ToPointer(), skipVTables);
        }

        internal static VpxRefFrame __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxRefFrame)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxRefFrame __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxRefFrame(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxRefFrame(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxRefFrame(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxRefFrame()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRefFrame.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxRefFrame(global::Vpx.VpxRefFrame _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRefFrame.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxRefFrame.__Internal*) __Instance) = *((global::Vpx.VpxRefFrame.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>which reference frame</summary>
        public global::Vpx.VpxRefFrameType FrameType
        {
            get
            {
                return ((__Internal*)__Instance)->frame_type;
            }

            set
            {
                ((__Internal*)__Instance)->frame_type = value;
            }
        }

        /// <summary>reference frame data in image format</summary>
        public global::Vpx.VpxImage Img
        {
            get
            {
                return global::Vpx.VpxImage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->img));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->img = *(global::Vpx.VpxImage.__Internal*) value.__Instance;
            }
        }
    }

    /// <summary>VP9 specific reference frame data struct</summary>
    /// <remarks>Define the data struct to access vp9 reference frames.</remarks>
    public unsafe partial class Vp9RefFrame : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 144)]
        public partial struct __Internal
        {
            internal int idx;
            internal global::Vpx.VpxImage.__Internal img;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vp9_ref_frame@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.Vp9RefFrame> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.Vp9RefFrame>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.Vp9RefFrame managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.Vp9RefFrame managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static Vp9RefFrame __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new Vp9RefFrame(native.ToPointer(), skipVTables);
        }

        internal static Vp9RefFrame __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (Vp9RefFrame)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static Vp9RefFrame __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new Vp9RefFrame(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private Vp9RefFrame(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected Vp9RefFrame(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public Vp9RefFrame()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.Vp9RefFrame.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public Vp9RefFrame(global::Vpx.Vp9RefFrame _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.Vp9RefFrame.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.Vp9RefFrame.__Internal*) __Instance) = *((global::Vpx.Vp9RefFrame.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>frame index to get (input)</summary>
        public int Idx
        {
            get
            {
                return ((__Internal*)__Instance)->idx;
            }

            set
            {
                ((__Internal*)__Instance)->idx = value;
            }
        }

        /// <summary>img structure to populate (output)</summary>
        public global::Vpx.VpxImage Img
        {
            get
            {
                return global::Vpx.VpxImage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->img));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->img = *(global::Vpx.VpxImage.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class vp8
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8_SET_REFERENCE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_ref_frame@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8SET_REFERENCE(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8_COPY_REFERENCE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_ref_frame@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8COPY_REFERENCE(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8_SET_POSTPROC@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvp8_postproc_cfg@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8SET_POSTPROC(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9_GET_REFERENCE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvp9_ref_frame@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9GET_REFERENCE(__IntPtr _0, int _1, __IntPtr _2);
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8SET_REFERENCE(global::Vpx.VpxCodecCtx _0, int _1, global::Vpx.VpxRefFrame _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8SET_REFERENCE(__arg0, _1, __arg2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8COPY_REFERENCE(global::Vpx.VpxCodecCtx _0, int _1, global::Vpx.VpxRefFrame _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8COPY_REFERENCE(__arg0, _1, __arg2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8SET_POSTPROC(global::Vpx.VpxCodecCtx _0, int _1, global::Vpx.Vp8PostprocCfg _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8SET_POSTPROC(__arg0, _1, __arg2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9GET_REFERENCE(global::Vpx.VpxCodecCtx _0, int _1, global::Vpx.Vp9RefFrame _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9GET_REFERENCE(__arg0, _1, __arg2);
            return ___ret;
        }
    }

    /// <summary>VPx encoder control functions</summary>
    /// <remarks>
    /// <para>This set of macros define the control functions available for VPx</para>
    /// <para>encoder interface.</para>
    /// <para>#vpx_codec_control</para>
    /// </remarks>
    public enum Vp8eEncControlId
    {
        /// <summary>Codec control function to pass an ROI map to encoder.</summary>
        /// <remarks>Supported in codecs: VP8</remarks>
        VP8E_SET_ROI_MAP = 8,
        /// <summary>Codec control function to pass an Active map to encoder.</summary>
        /// <remarks>Supported in codecs: VP8, VP9</remarks>
        VP8E_SET_ACTIVEMAP = 9,
        /// <summary>Codec control function to set encoder scaling mode.</summary>
        /// <remarks>Supported in codecs: VP8, VP9</remarks>
        VP8E_SET_SCALEMODE = 11,
        /// <summary>Codec control function to set encoder internal speed settings.</summary>
        /// <remarks>
        /// <para>Changes in this value influences, among others, the encoder's selection</para>
        /// <para>of motion estimation methods. Values greater than 0 will increase encoder</para>
        /// <para>speed at the expense of quality.</para>
        /// <para>Valid range for VP8: -16..16</para>
        /// <para>Valid range for VP9: -9..9</para>
        /// <para>A negative value (-n) is treated as its absolute value (n) in VP9.</para>
        /// <para>Supported in codecs: VP8, VP9</para>
        /// </remarks>
        VP8E_SET_CPUUSED = 13,
        /// <summary>Codec control function to enable automatic use of arf frames.</summary>
        /// <remarks>
        /// <para>Valid range for VP8: 0..1</para>
        /// <para>Valid range for VP9: 0..6</para>
        /// <para>Supported in codecs: VP8, VP9</para>
        /// </remarks>
        VP8E_SET_ENABLEAUTOALTREF = 14,
        /// <summary>control function to set noise sensitivity</summary>
        /// <remarks>
        /// <para>0: off, 1: OnYOnly, 2: OnYUV,</para>
        /// <para>3: OnYUVAggressive, 4: Adaptive</para>
        /// <para>Supported in codecs: VP8</para>
        /// </remarks>
        VP8E_SET_NOISE_SENSITIVITY = 15,
        /// <summary>
        /// <para>Codec control function to set higher sharpness at the expense</para>
        /// <para>of a lower PSNR.</para>
        /// </summary>
        /// <remarks>
        /// <para>Valid range: 0..7</para>
        /// <para>Supported in codecs: VP8, VP9</para>
        /// </remarks>
        VP8E_SET_SHARPNESS = 16,
        /// <summary>Codec control function to set the threshold for MBs treated static.</summary>
        /// <remarks>Supported in codecs: VP8, VP9</remarks>
        VP8E_SET_STATIC_THRESHOLD = 17,
        /// <summary>Codec control function to set the number of token partitions.</summary>
        /// <remarks>Supported in codecs: VP8</remarks>
        VP8E_SET_TOKEN_PARTITIONS = 18,
        /// <summary>Codec control function to get last quantizer chosen by the encoder.</summary>
        /// <remarks>
        /// <para>Return value uses internal quantizer scale defined by the codec.</para>
        /// <para>Supported in codecs: VP8, VP9</para>
        /// </remarks>
        VP8E_GET_LAST_QUANTIZER = 19,
        /// <summary>Codec control function to get last quantizer chosen by the encoder.</summary>
        /// <remarks>
        /// <para>Return value uses the 0..63 scale as used by the rc_*_quantizer config</para>
        /// <para>parameters.</para>
        /// <para>Supported in codecs: VP8, VP9</para>
        /// </remarks>
        VP8E_GET_LAST_QUANTIZER_64 = 20,
        /// <summary>Codec control function to set the max no of frames to create arf.</summary>
        /// <remarks>Supported in codecs: VP8, VP9</remarks>
        VP8E_SET_ARNR_MAXFRAMES = 21,
        /// <summary>Codec control function to set the filter strength for the arf.</summary>
        /// <remarks>Supported in codecs: VP8, VP9</remarks>
        VP8E_SET_ARNR_STRENGTH = 22,
        /// <remarks>control function to set the filter type to use for the arf.</remarks>
        VP8E_SET_ARNR_TYPE = 23,
        /// <summary>Codec control function to set visual tuning.</summary>
        /// <remarks>Supported in codecs: VP8, VP9</remarks>
        VP8E_SET_TUNING = 24,
        /// <summary>Codec control function to set constrained / constant quality level.</summary>
        /// <remarks>
        /// <para>For this value to be used vpx_codec_enc_cfg_t::rc_end_usage must</para>
        /// <para>be set to #VPX_CQ or #VPX_Q</para>
        /// <para>Valid range: 0..63</para>
        /// <para>Supported in codecs: VP8, VP9</para>
        /// </remarks>
        VP8E_SET_CQ_LEVEL = 25,
        /// <summary>Codec control function to set Max data rate for Intra frames.</summary>
        /// <remarks>
        /// <para>This value controls additional clamping on the maximum size of a</para>
        /// <para>keyframe. It is expressed as a percentage of the average</para>
        /// <para>per-frame bitrate, with the special (and default) value 0 meaning</para>
        /// <para>unlimited, or no additional clamping beyond the codec's built-in</para>
        /// <para>algorithm.</para>
        /// <para>For example, to allocate no more than 4.5 frames worth of bitrate</para>
        /// <para>to a keyframe, set this to 450.</para>
        /// <para>Supported in codecs: VP8, VP9</para>
        /// </remarks>
        VP8E_SET_MAX_INTRA_BITRATE_PCT = 26,
        /// <summary>Codec control function to set reference and update frame flags.</summary>
        /// <remarks>Supported in codecs: VP8</remarks>
        VP8E_SET_FRAME_FLAGS = 27,
        /// <summary>Codec control function to set max data rate for Inter frames.</summary>
        /// <remarks>
        /// <para>This value controls additional clamping on the maximum size of an</para>
        /// <para>inter frame. It is expressed as a percentage of the average</para>
        /// <para>per-frame bitrate, with the special (and default) value 0 meaning</para>
        /// <para>unlimited, or no additional clamping beyond the codec's built-in</para>
        /// <para>algorithm.</para>
        /// <para>For example, to allow no more than 4.5 frames worth of bitrate</para>
        /// <para>to an inter frame, set this to 450.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_MAX_INTER_BITRATE_PCT = 28,
        /// <summary>Boost percentage for Golden Frame in CBR mode.</summary>
        /// <remarks>
        /// <para>This value controls the amount of boost given to Golden Frame in</para>
        /// <para>CBR mode. It is expressed as a percentage of the average</para>
        /// <para>per-frame bitrate, with the special (and default) value 0 meaning</para>
        /// <para>the feature is off, i.e., no golden frame boost in CBR mode and</para>
        /// <para>average bitrate target is used.</para>
        /// <para>For example, to allow 100% more bits, i.e., 2X, in a golden frame</para>
        /// <para>than average frame, set this to 100.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_GF_CBR_BOOST_PCT = 29,
        /// <summary>Codec control function to set the temporal layer id.</summary>
        /// <remarks>
        /// <para>For temporal scalability: this control allows the application to set the</para>
        /// <para>layer id for each frame to be encoded. Note that this control must be set</para>
        /// <para>for every frame prior to encoding. The usage of this control function</para>
        /// <para>supersedes the internal temporal pattern counter, which is now deprecated.</para>
        /// <para>Supported in codecs: VP8</para>
        /// </remarks>
        VP8E_SET_TEMPORAL_LAYER_ID = 30,
        /// <summary>Codec control function to set encoder screen content mode.</summary>
        /// <remarks>
        /// <para>0: off, 1: On, 2: On with more aggressive rate control.</para>
        /// <para>Supported in codecs: VP8</para>
        /// </remarks>
        VP8E_SET_SCREEN_CONTENT_MODE = 31,
        /// <summary>Codec control function to set lossless encoding mode.</summary>
        /// <remarks>
        /// <para>VP9 can operate in lossless encoding mode, in which the bitstream</para>
        /// <para>produced will be able to decode and reconstruct a perfect copy of</para>
        /// <para>input source. This control function provides a mean to switch encoder</para>
        /// <para>into lossless coding mode(1) or normal coding mode(0) that may be lossy.</para>
        /// <para>0 = lossy coding mode</para>
        /// <para>1 = lossless coding mode</para>
        /// <para>By default, encoder operates in normal coding mode (maybe lossy).</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_LOSSLESS = 32,
        /// <summary>Codec control function to set number of tile columns.</summary>
        /// <remarks>
        /// <para>In encoding and decoding, VP9 allows an input image frame be partitioned</para>
        /// <para>into separated vertical tile columns, which can be encoded or decoded</para>
        /// <para>independently. This enables easy implementation of parallel encoding and</para>
        /// <para>decoding. This control requests the encoder to use column tiles in</para>
        /// <para>encoding an input frame, with number of tile columns (in Log2 unit) as</para>
        /// <para>the parameter:</para>
        /// <para>0 = 1 tile column</para>
        /// <para>1 = 2 tile columns</para>
        /// <para>2 = 4 tile columns</para>
        /// <para>.....</para>
        /// <para>n = 2**n tile columns</para>
        /// <para>The requested tile columns will be capped by the encoder based on image</para>
        /// <para>size limitations (The minimum width of a tile column is 256 pixels, the</para>
        /// <para>maximum is 4096).</para>
        /// <para>By default, the value is 6, i.e., the maximum number of tiles supported by</para>
        /// <para>the resolution.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_TILE_COLUMNS = 33,
        /// <summary>Codec control function to set number of tile rows.</summary>
        /// <remarks>
        /// <para>In encoding and decoding, VP9 allows an input image frame be partitioned</para>
        /// <para>into separated horizontal tile rows. Tile rows are encoded or decoded</para>
        /// <para>sequentially. Even though encoding/decoding of later tile rows depends on</para>
        /// <para>earlier ones, this allows the encoder to output data packets for tile rows</para>
        /// <para>prior to completely processing all tile rows in a frame, thereby reducing</para>
        /// <para>the latency in processing between input and output. The parameter</para>
        /// <para>for this control describes the number of tile rows, which has a valid</para>
        /// <para>range [0, 2]:</para>
        /// <para>0 = 1 tile row</para>
        /// <para>1 = 2 tile rows</para>
        /// <para>2 = 4 tile rows</para>
        /// <para>By default, the value is 0, i.e. one single row tile for entire image.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_TILE_ROWS = 34,
        /// <summary>Codec control function to enable frame parallel decoding feature.</summary>
        /// <remarks>
        /// <para>VP9 has a bitstream feature to reduce decoding dependency between frames</para>
        /// <para>by turning off backward update of probability context used in encoding</para>
        /// <para>and decoding. This allows staged parallel processing of more than one</para>
        /// <para>video frame in the decoder. This control function provides a means to</para>
        /// <para>turn this feature on or off for bitstreams produced by encoder.</para>
        /// <para>By default, this feature is on.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_FRAME_PARALLEL_DECODING = 35,
        /// <summary>Codec control function to set adaptive quantization mode.</summary>
        /// <remarks>
        /// <para>VP9 has a segment based feature that allows encoder to adaptively change</para>
        /// <para>quantization parameter for each segment within a frame to improve the</para>
        /// <para>subjective quality. This control makes encoder operate in one of the</para>
        /// <para>several AQ_modes supported.</para>
        /// <para>By default, encoder operates with AQ_Mode 0(adaptive quantization off).</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_AQ_MODE = 36,
        /// <summary>Codec control function to enable/disable periodic Q boost.</summary>
        /// <remarks>
        /// <para>One VP9 encoder speed feature is to enable quality boost by lowering</para>
        /// <para>frame level Q periodically. This control function provides a mean to</para>
        /// <para>turn on/off this feature.</para>
        /// <para>0 = off</para>
        /// <para>1 = on</para>
        /// <para>By default, the encoder is allowed to use this feature for appropriate</para>
        /// <para>encoding modes.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_FRAME_PERIODIC_BOOST = 37,
        /// <summary>Codec control function to set noise sensitivity.</summary>
        /// <remarks>
        /// <para>0: off, 1: On(YOnly), 2: For SVC only, on top two spatial layers(YOnly)</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_NOISE_SENSITIVITY = 38,
        /// <summary>Codec control function to turn on/off SVC in encoder.</summary>
        /// <remarks>
        /// <para>Return value is VPX_CODEC_INVALID_PARAM if the encoder does not</para>
        /// <para>support SVC in its current encoding mode</para>
        /// <para>0: off, 1: on</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_SVC = 39,
        /// <summary>Codec control function to pass an ROI map to encoder.</summary>
        /// <remarks>Supported in codecs: VP9</remarks>
        VP9E_SET_ROI_MAP = 40,
        /// <summary>Codec control function to set parameters for SVC.</summary>
        /// <remarks>
        /// <para>Parameters contain min_q, max_q, scaling factor for each of the</para>
        /// <para>SVC layers.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_SVC_PARAMETERS = 41,
        /// <summary>Codec control function to set svc layer for spatial and temporal.</summary>
        /// <remarks>
        /// <para>Valid ranges: 0..#vpx_codec_enc_cfg::ss_number_layers for spatial</para>
        /// <para>layer and 0..#vpx_codec_enc_cfg::ts_number_layers for</para>
        /// <para>temporal layer.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_SVC_LAYER_ID = 42,
        /// <summary>Codec control function to set content type.</summary>
        /// <remarks>
        /// <para>Valid parameter range:</para>
        /// <para>VP9E_CONTENT_DEFAULT = Regular video content (Default)</para>
        /// <para>VP9E_CONTENT_SCREEN  = Screen capture content</para>
        /// <para>VP9E_CONTENT_FILM    = Film content: improves grain retention</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_TUNE_CONTENT = 43,
        /// <summary>Codec control function to get svc layer ID.</summary>
        /// <remarks>
        /// <para>The layer ID returned is for the data packet from the registered</para>
        /// <para>callback function.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_GET_SVC_LAYER_ID = 44,
        /// <summary>Codec control function to register callback to get per layer packet.</summary>
        /// <remarks>
        /// <para>Parameter for this control function is a structure with a callback</para>
        /// <para>function and a pointer to private data used by the callback.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_REGISTER_CX_CALLBACK = 45,
        /// <summary>Codec control function to set color space info.</summary>
        /// <remarks>
        /// <para>Valid ranges: 0..7, default is &quot;UNKNOWN&quot;.</para>
        /// <para>0 = UNKNOWN,</para>
        /// <para>1 = BT_601</para>
        /// <para>2 = BT_709</para>
        /// <para>3 = SMPTE_170</para>
        /// <para>4 = SMPTE_240</para>
        /// <para>5 = BT_2020</para>
        /// <para>6 = RESERVED</para>
        /// <para>7 = SRGB</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_COLOR_SPACE = 46,
        /// <summary>Codec control function to set minimum interval between GF/ARF frames</summary>
        /// <remarks>
        /// <para>By default the value is set as 4.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_MIN_GF_INTERVAL = 48,
        /// <summary>Codec control function to set minimum interval between GF/ARF frames</summary>
        /// <remarks>
        /// <para>By default the value is set as 16.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_MAX_GF_INTERVAL = 49,
        /// <summary>Codec control function to get an Active map back from the encoder.</summary>
        /// <remarks>Supported in codecs: VP9</remarks>
        VP9E_GET_ACTIVEMAP = 50,
        /// <summary>Codec control function to set color range bit.</summary>
        /// <remarks>
        /// <para>Valid ranges: 0..1, default is 0</para>
        /// <para>0 = Limited range (16..235 or HBD equivalent)</para>
        /// <para>1 = Full range (0..255 or HBD equivalent)</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_COLOR_RANGE = 51,
        /// <summary>
        /// <para>Codec control function to set the frame flags and buffer indices</para>
        /// <para>for spatial layers. The frame flags and buffer indices are set using the</para>
        /// <para>struct #vpx_svc_ref_frame_config defined below.</para>
        /// </summary>
        /// <remarks>Supported in codecs: VP9</remarks>
        VP9E_SET_SVC_REF_FRAME_CONFIG = 52,
        /// <summary>Codec control function to set intended rendering image size.</summary>
        /// <remarks>
        /// <para>By default, this is identical to the image size in pixels.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_RENDER_SIZE = 53,
        /// <summary>Codec control function to set target level.</summary>
        /// <remarks>
        /// <para>255: off (default); 0: only keep level stats; 10: target for level 1.0;</para>
        /// <para>11: target for level 1.1; ... 62: target for level 6.2</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_TARGET_LEVEL = 54,
        /// <summary>Codec control function to set row level multi-threading.</summary>
        /// <remarks>
        /// <para>0 : off, 1 : on</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_ROW_MT = 55,
        /// <summary>Codec control function to get bitstream level.</summary>
        /// <remarks>Supported in codecs: VP9</remarks>
        VP9E_GET_LEVEL = 56,
        /// <summary>
        /// <para>Codec control function to enable/disable special mode for altref</para>
        /// <para>adaptive quantization. You can use it with --aq-mode concurrently.</para>
        /// </summary>
        /// <remarks>
        /// <para>Enable special adaptive quantization for altref frames based on their</para>
        /// <para>expected prediction quality for the future frames.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_ALT_REF_AQ = 57,
        /// <summary>Boost percentage for Golden Frame in CBR mode.</summary>
        /// <remarks>
        /// <para>This value controls the amount of boost given to Golden Frame in</para>
        /// <para>CBR mode. It is expressed as a percentage of the average</para>
        /// <para>per-frame bitrate, with the special (and default) value 0 meaning</para>
        /// <para>the feature is off, i.e., no golden frame boost in CBR mode and</para>
        /// <para>average bitrate target is used.</para>
        /// <para>For example, to allow 100% more bits, i.e., 2X, in a golden frame</para>
        /// <para>than average frame, set this to 100.</para>
        /// <para>Supported in codecs: VP8</para>
        /// </remarks>
        VP8E_SET_GF_CBR_BOOST_PCT = 58,
        /// <summary>
        /// <para>Codec control function to enable the extreme motion vector unit test</para>
        /// <para>in VP9. Please note that this is only used in motion vector unit test.</para>
        /// </summary>
        /// <remarks>
        /// <para>0 : off, 1 : MAX_EXTREME_MV, 2 : MIN_EXTREME_MV</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_ENABLE_MOTION_VECTOR_UNIT_TEST = 59,
        /// <summary>
        /// <para>Codec control function to constrain the inter-layer prediction</para>
        /// <para>(prediction of lower spatial resolution) in VP9 SVC.</para>
        /// </summary>
        /// <remarks>
        /// <para>0 : inter-layer prediction on, 1 : off, 2 : off only on non-key frames</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_SVC_INTER_LAYER_PRED = 60,
        /// <summary>
        /// <para>Codec control function to set mode and thresholds for frame</para>
        /// <para>dropping in SVC. Drop frame thresholds are set per-layer. Mode is set as:</para>
        /// <para>0 : layer-dependent dropping, 1 : constrained dropping, current layer drop</para>
        /// <para>forces drop on all upper layers. Default mode is 0.</para>
        /// </summary>
        /// <remarks>Supported in codecs: VP9</remarks>
        VP9E_SET_SVC_FRAME_DROP_LAYER = 61,
        /// <summary>
        /// <para>Codec control function to get the refresh and reference flags and</para>
        /// <para>the buffer indices, up to the last encoded spatial layer.</para>
        /// </summary>
        /// <remarks>Supported in codecs: VP9</remarks>
        VP9E_GET_SVC_REF_FRAME_CONFIG = 62,
        /// <summary>
        /// <para>Codec control function to enable/disable use of golden reference as</para>
        /// <para>a second temporal reference for SVC. Only used when inter-layer prediction</para>
        /// <para>is disabled on INTER frames.</para>
        /// </summary>
        /// <remarks>
        /// <para>0: Off, 1: Enabled (default)</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_SVC_GF_TEMPORAL_REF = 63,
        /// <summary>
        /// <para>Codec control function to enable spatial layer sync frame, for any</para>
        /// <para>spatial layer. Enabling it for layer k means spatial layer k will disable</para>
        /// <para>all temporal prediction, but keep the inter-layer prediction. It will</para>
        /// <para>refresh any temporal reference buffer for that layer, and reset the</para>
        /// <para>temporal layer for the superframe to 0. Setting the layer sync for base</para>
        /// <para>spatial layer forces a key frame. Default is off (0) for all spatial</para>
        /// <para>layers. Spatial layer sync flag is reset to 0 after each encoded layer,</para>
        /// <para>so when control is invoked it is only used for the current superframe.</para>
        /// </summary>
        /// <remarks>
        /// <para>0: Off (default), 1: Enabled</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_SVC_SPATIAL_LAYER_SYNC = 64,
        /// <summary>Codec control function to enable temporal dependency model.</summary>
        /// <remarks>
        /// <para>Vp9 allows the encoder to run temporal dependency model and use it to</para>
        /// <para>improve the compression performance. To enable, set this parameter to be</para>
        /// <para>1. The default value is set to be 1.</para>
        /// </remarks>
        VP9E_SET_TPL = 65,
        /// <summary>Codec control function to enable postencode frame drop.</summary>
        /// <remarks>
        /// <para>This will allow encoder to drop frame after it's encoded.</para>
        /// <para>0: Off (default), 1: Enabled</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_POSTENCODE_DROP = 66,
        /// <summary>Codec control function to set delta q for uv.</summary>
        /// <remarks>
        /// <para>Cap it at +/-15.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_DELTA_Q_UV = 67,
        /// <summary>Codec control function to disable increase Q on overshoot in CBR.</summary>
        /// <remarks>
        /// <para>0: On (default), 1: Disable.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_DISABLE_OVERSHOOT_MAXQ_CBR = 68,
        /// <summary>Codec control function to disable loopfilter.</summary>
        /// <remarks>
        /// <para>0: Loopfilter on all frames, 1: Disable on non reference frames.</para>
        /// <para>2: Disable on all frames.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_DISABLE_LOOPFILTER = 69,
        /// <summary>Codec control function to enable external rate control library.</summary>
        /// <remarks>
        /// <para>args[0]: path of the rate control library</para>
        /// <para>args[1]: private config of the rate control library</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_EXTERNAL_RATE_CONTROL = 70,
        /// <summary>Codec control to disable internal features in rate control.</summary>
        /// <remarks>
        /// <para>This will do 3 things, only for 1 pass:</para>
        /// <para>- Turn off low motion computation</para>
        /// <para>- Turn off gf update constraint on key frame frequency</para>
        /// <para>- Turn off content mode for cyclic refresh</para>
        /// <para>With those, the rate control is expected to work exactly the same as the</para>
        /// <para>interface provided in ratectrl_rtc.cc/h</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_RTC_EXTERNAL_RATECTRL = 71,
        /// <summary>Codec control function to get loopfilter level in the encoder.</summary>
        /// <remarks>Supported in codecs: VP9</remarks>
        VP9E_GET_LOOPFILTER_LEVEL = 72,
        /// <summary>Codec control to get last quantizers for all spatial layers.</summary>
        /// <remarks>
        /// <para>Return value uses an array of internal quantizers scale defined by the</para>
        /// <para>codec, for all spatial layers.</para>
        /// <para>The size of the array passed in should be #VPX_SS_MAX_LAYERS.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_GET_LAST_QUANTIZER_SVC_LAYERS = 73,
        /// <summary>Codec control to disable internal features in rate control.</summary>
        /// <remarks>
        /// <para>This will turn off cyclic refresh for vp8.</para>
        /// <para>With this, the rate control is expected to work exactly the same as the</para>
        /// <para>interface provided in vp8_ratectrl_rtc.cc/h</para>
        /// <para>Supported in codecs: VP8</para>
        /// </remarks>
        VP8E_SET_RTC_EXTERNAL_RATECTRL = 74,
        /// <summary>Codec control to set quantizer for the next frame.</summary>
        /// <remarks>
        /// <para>This will turn off cyclic refresh. Only applicable to 1-pass without</para>
        /// <para>spatial layers.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9E_SET_QUANTIZER_ONE_PASS = 75
    }

    /// <summary>vpx 1-D scaling mode</summary>
    /// <remarks>This set of constants define 1-D vpx scaling modes</remarks>
    public enum VpxScalingMode1d
    {
        VP8E_NORMAL = 0,
        VP8E_FOURFIVE = 1,
        VP8E_THREEFIVE = 2,
        VP8E_ONETWO = 3
    }

    /// <summary>Temporal layering mode enum for VP9 SVC.</summary>
    /// <remarks>
    /// <para>This set of macros define the different temporal layering modes.</para>
    /// <para>Supported codecs: VP9 (in SVC mode)</para>
    /// </remarks>
    public enum Vp9eTemporalLayeringMode
    {
        /// <summary>
        /// <para>No temporal layering.</para>
        /// <para>Used when only spatial layering is used.</para>
        /// </summary>
        VP9E_TEMPORAL_LAYERING_MODE_NOLAYERING = 0,
        /// <summary>
        /// <para>Bypass mode.</para>
        /// <para>Used when application needs to control temporal layering.</para>
        /// <para>This will only work when the number of spatial layers equals 1.</para>
        /// </summary>
        VP9E_TEMPORAL_LAYERING_MODE_BYPASS = 1,
        /// <summary>0-1-0-1... temporal layering scheme with two temporal layers.</summary>
        VP9E_TEMPORAL_LAYERING_MODE_0101 = 2,
        /// <summary>0-2-1-2... temporal layering scheme with three temporal layers.</summary>
        VP9E_TEMPORAL_LAYERING_MODE_0212 = 3
    }

    /// <summary>VP8 token partition mode</summary>
    /// <remarks>
    /// <para>This defines VP8 partitioning mode for compressed data, i.e., the number of</para>
    /// <para>sub-streams in the bitstream. Used for parallelized decoding.</para>
    /// </remarks>
    public enum Vp8eTokenPartitions
    {
        VP8ONE_TOKENPARTITION = 0,
        VP8TWO_TOKENPARTITION = 1,
        VP8FOUR_TOKENPARTITION = 2,
        VP8EIGHT_TOKENPARTITION = 3
    }

    /// <summary>brief VP9 encoder content type</summary>
    public enum Vp9eTuneContent
    {
        VP9E_CONTENT_DEFAULT = 0,
        VP9E_CONTENT_SCREEN = 1,
        VP9E_CONTENT_FILM = 2,
        VP9E_CONTENT_INVALID = 3
    }

    /// <summary>VP8 model tuning parameters</summary>
    /// <remarks>Changes the encoder to tune for certain types of input material.</remarks>
    public enum Vp8eTuning
    {
        VP8TUNE_PSNR = 0,
        VP8TUNE_SSIM = 1
    }

    /// <summary>VP9 svc frame dropping mode.</summary>
    /// <remarks>This defines the frame drop mode for SVC.</remarks>
    public enum SVC_LAYER_DROP_MODE
    {
        CONSTRAINED_LAYER_DROP = 0,
        /// <summary>Any spatial layer can drop.</summary>
        LAYER_DROP = 1,
        /// <summary>Only full superframe can drop.</summary>
        FULL_SUPERFRAME_DROP = 2,
        CONSTRAINED_FROM_ABOVE_DROP = 3
    }

    /// <summary>vpx 1-D scaling mode</summary>
    /// <remarks>This set of constants define 1-D vpx scaling modes</remarks>
    /// <summary>Temporal layering mode enum for VP9 SVC.</summary>
    /// <remarks>
    /// <para>This set of macros define the different temporal layering modes.</para>
    /// <para>Supported codecs: VP9 (in SVC mode)</para>
    /// </remarks>
    /// <summary>vpx region of interest map</summary>
    /// <remarks>These defines the data structures for the region of interest map</remarks>
    /// <summary>vpx active region map</summary>
    /// <remarks>These defines the data structures for active region map</remarks>
    /// <summary>vpx image scaling mode</summary>
    /// <remarks>This defines the data structure for image scaling mode</remarks>
    /// <summary>VP8 token partition mode</summary>
    /// <remarks>
    /// <para>This defines VP8 partitioning mode for compressed data, i.e., the number of</para>
    /// <para>sub-streams in the bitstream. Used for parallelized decoding.</para>
    /// </remarks>
    /// <summary>brief VP9 encoder content type</summary>
    /// <summary>VP8 model tuning parameters</summary>
    /// <remarks>Changes the encoder to tune for certain types of input material.</remarks>
    /// <summary>vp9 svc layer parameters</summary>
    /// <remarks>
    /// <para>This defines the spatial and temporal layer id numbers for svc encoding.</para>
    /// <para>This is used with the #VP9E_SET_SVC_LAYER_ID control to set the spatial and</para>
    /// <para>temporal layer id for the current frame.</para>
    /// </remarks>
    /// <summary>vp9 svc frame flag parameters.</summary>
    /// <remarks>
    /// <para>This defines the frame flags and buffer indices for each spatial layer for</para>
    /// <para>svc encoding.</para>
    /// <para>This is used with the #VP9E_SET_SVC_REF_FRAME_CONFIG control to set frame</para>
    /// <para>flags and buffer indices for each spatial layer for the current (super)frame.</para>
    /// </remarks>
    /// <summary>VP9 svc frame dropping mode.</summary>
    /// <remarks>This defines the frame drop mode for SVC.</remarks>
    /// <summary>vp9 svc frame dropping parameters.</summary>
    /// <remarks>
    /// <para>This defines the frame drop thresholds for each spatial layer, and</para>
    /// <para>the frame dropping mode: 0 = layer based frame dropping (default),</para>
    /// <para>1 = constrained dropping where current layer drop forces all upper</para>
    /// <para>spatial layers to drop.</para>
    /// </remarks>
    /// <summary>vp9 svc spatial layer sync parameters.</summary>
    /// <remarks>This defines the spatial layer sync flag, defined per spatial layer.</remarks>
    /// <summary>vpx region of interest map</summary>
    /// <remarks>These defines the data structures for the region of interest map</remarks>
    public unsafe partial class VpxRoiMap : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 168)]
        public partial struct __Internal
        {
            internal byte enabled;
            internal __IntPtr roi_map;
            internal uint rows;
            internal uint cols;
            internal fixed int delta_q[8];
            internal fixed int delta_lf[8];
            internal fixed int skip[8];
            internal fixed int ref_frame[8];
            internal fixed uint static_threshold[4];

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_roi_map@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRoiMap> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxRoiMap>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxRoiMap managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxRoiMap managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxRoiMap __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxRoiMap(native.ToPointer(), skipVTables);
        }

        internal static VpxRoiMap __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxRoiMap)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxRoiMap __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxRoiMap(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxRoiMap(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxRoiMap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxRoiMap()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRoiMap.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxRoiMap(global::Vpx.VpxRoiMap _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxRoiMap.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxRoiMap.__Internal*) __Instance) = *((global::Vpx.VpxRoiMap.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>If ROI is enabled.</summary>
        public byte Enabled
        {
            get
            {
                return ((__Internal*)__Instance)->enabled;
            }

            set
            {
                ((__Internal*)__Instance)->enabled = value;
            }
        }

        /// <summary>
        /// <para>An id between 0-3 (0-7 for vp9) for each 16x16 (8x8 for VP9)</para>
        /// <para>region within a frame.</para>
        /// </summary>
        public byte* RoiMap
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->roi_map;
            }

            set
            {
                ((__Internal*)__Instance)->roi_map = (__IntPtr) value;
            }
        }

        /// <summary>Number of rows.</summary>
        public uint Rows
        {
            get
            {
                return ((__Internal*)__Instance)->rows;
            }

            set
            {
                ((__Internal*)__Instance)->rows = value;
            }
        }

        /// <summary>Number of columns.</summary>
        public uint Cols
        {
            get
            {
                return ((__Internal*)__Instance)->cols;
            }

            set
            {
                ((__Internal*)__Instance)->cols = value;
            }
        }

        /// <summary>Quantizer deltas. Valid range: [-63, 63].</summary>
        public int[] DeltaQ
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->delta_q, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->delta_q[i] = value[i];
                }
            }
        }

        /// <summary>Loop filter deltas. Valid range: [-63, 63].</summary>
        public int[] DeltaLf
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->delta_lf, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->delta_lf[i] = value[i];
                }
            }
        }

        /// <summary>Skip this block.</summary>
        public int[] Skip
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->skip, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->skip[i] = value[i];
                }
            }
        }

        /// <summary>Reference frame for this block.</summary>
        public int[] RefFrame
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->ref_frame, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->ref_frame[i] = value[i];
                }
            }
        }

        /// <summary>Static breakout threshold for each segment. Only used in VP8.</summary>
        public uint[] StaticThreshold
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->static_threshold, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->static_threshold[i] = value[i];
                }
            }
        }
    }

    /// <summary>vpx active region map</summary>
    /// <remarks>These defines the data structures for active region map</remarks>
    public unsafe partial class VpxActiveMap : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr active_map;
            internal uint rows;
            internal uint cols;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_active_map@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxActiveMap> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxActiveMap>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxActiveMap managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxActiveMap managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxActiveMap __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxActiveMap(native.ToPointer(), skipVTables);
        }

        internal static VpxActiveMap __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxActiveMap)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxActiveMap __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxActiveMap(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxActiveMap(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxActiveMap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxActiveMap()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxActiveMap.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxActiveMap(global::Vpx.VpxActiveMap _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxActiveMap.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxActiveMap.__Internal*) __Instance) = *((global::Vpx.VpxActiveMap.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>specify an on (1) or off (0) each 16x16 region within a frame</summary>
        public byte* ActiveMap
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->active_map;
            }

            set
            {
                ((__Internal*)__Instance)->active_map = (__IntPtr) value;
            }
        }

        /// <summary>number of rows</summary>
        public uint Rows
        {
            get
            {
                return ((__Internal*)__Instance)->rows;
            }

            set
            {
                ((__Internal*)__Instance)->rows = value;
            }
        }

        /// <summary>number of cols</summary>
        public uint Cols
        {
            get
            {
                return ((__Internal*)__Instance)->cols;
            }

            set
            {
                ((__Internal*)__Instance)->cols = value;
            }
        }
    }

    /// <summary>vpx image scaling mode</summary>
    /// <remarks>This defines the data structure for image scaling mode</remarks>
    public unsafe partial class VpxScalingMode : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            internal global::Vpx.VpxScalingMode1d h_scaling_mode;
            internal global::Vpx.VpxScalingMode1d v_scaling_mode;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_scaling_mode@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxScalingMode> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxScalingMode>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxScalingMode managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxScalingMode managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxScalingMode __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxScalingMode(native.ToPointer(), skipVTables);
        }

        internal static VpxScalingMode __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxScalingMode)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxScalingMode __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxScalingMode(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxScalingMode(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxScalingMode(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxScalingMode()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxScalingMode.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxScalingMode(global::Vpx.VpxScalingMode _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxScalingMode.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxScalingMode.__Internal*) __Instance) = *((global::Vpx.VpxScalingMode.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>horizontal scaling mode</summary>
        public global::Vpx.VpxScalingMode1d HScalingMode
        {
            get
            {
                return ((__Internal*)__Instance)->h_scaling_mode;
            }

            set
            {
                ((__Internal*)__Instance)->h_scaling_mode = value;
            }
        }

        /// <summary>vertical scaling mode</summary>
        public global::Vpx.VpxScalingMode1d VScalingMode
        {
            get
            {
                return ((__Internal*)__Instance)->v_scaling_mode;
            }

            set
            {
                ((__Internal*)__Instance)->v_scaling_mode = value;
            }
        }
    }

    /// <summary>vp9 svc layer parameters</summary>
    /// <remarks>
    /// <para>This defines the spatial and temporal layer id numbers for svc encoding.</para>
    /// <para>This is used with the #VP9E_SET_SVC_LAYER_ID control to set the spatial and</para>
    /// <para>temporal layer id for the current frame.</para>
    /// </remarks>
    public unsafe partial class VpxSvcLayerId : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal int spatial_layer_id;
            internal int temporal_layer_id;
            internal fixed int temporal_layer_id_per_spatial[5];

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_svc_layer_id@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxSvcLayerId> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxSvcLayerId>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxSvcLayerId managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxSvcLayerId managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxSvcLayerId __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxSvcLayerId(native.ToPointer(), skipVTables);
        }

        internal static VpxSvcLayerId __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxSvcLayerId)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxSvcLayerId __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxSvcLayerId(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxSvcLayerId(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxSvcLayerId(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxSvcLayerId()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxSvcLayerId.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxSvcLayerId(global::Vpx.VpxSvcLayerId _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxSvcLayerId.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxSvcLayerId.__Internal*) __Instance) = *((global::Vpx.VpxSvcLayerId.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>First spatial layer to start encoding.</summary>
        public int SpatialLayerId
        {
            get
            {
                return ((__Internal*)__Instance)->spatial_layer_id;
            }

            set
            {
                ((__Internal*)__Instance)->spatial_layer_id = value;
            }
        }

        /// <summary>Temporal layer id number.</summary>
        public int TemporalLayerId
        {
            get
            {
                return ((__Internal*)__Instance)->temporal_layer_id;
            }

            set
            {
                ((__Internal*)__Instance)->temporal_layer_id = value;
            }
        }

        /// <summary>Temp layer id.</summary>
        public int[] TemporalLayerIdPerSpatial
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->temporal_layer_id_per_spatial, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->temporal_layer_id_per_spatial[i] = value[i];
                }
            }
        }
    }

    /// <summary>vp9 svc frame flag parameters.</summary>
    /// <remarks>
    /// <para>This defines the frame flags and buffer indices for each spatial layer for</para>
    /// <para>svc encoding.</para>
    /// <para>This is used with the #VP9E_SET_SVC_REF_FRAME_CONFIG control to set frame</para>
    /// <para>flags and buffer indices for each spatial layer for the current (super)frame.</para>
    /// </remarks>
    public unsafe partial class VpxSvcRefFrameConfig : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 240)]
        public partial struct __Internal
        {
            internal fixed int lst_fb_idx[5];
            internal fixed int gld_fb_idx[5];
            internal fixed int alt_fb_idx[5];
            internal fixed int update_buffer_slot[5];
            internal fixed int update_last[5];
            internal fixed int update_golden[5];
            internal fixed int update_alt_ref[5];
            internal fixed int reference_last[5];
            internal fixed int reference_golden[5];
            internal fixed int reference_alt_ref[5];
            internal fixed long duration[5];

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_svc_ref_frame_config@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxSvcRefFrameConfig> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxSvcRefFrameConfig>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxSvcRefFrameConfig managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxSvcRefFrameConfig managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxSvcRefFrameConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxSvcRefFrameConfig(native.ToPointer(), skipVTables);
        }

        internal static VpxSvcRefFrameConfig __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxSvcRefFrameConfig)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxSvcRefFrameConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxSvcRefFrameConfig(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxSvcRefFrameConfig(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxSvcRefFrameConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxSvcRefFrameConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxSvcRefFrameConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxSvcRefFrameConfig(global::Vpx.VpxSvcRefFrameConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxSvcRefFrameConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxSvcRefFrameConfig.__Internal*) __Instance) = *((global::Vpx.VpxSvcRefFrameConfig.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Last buffer index.</summary>
        public int[] LstFbIdx
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->lst_fb_idx, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->lst_fb_idx[i] = value[i];
                }
            }
        }

        /// <summary>Golden buffer index.</summary>
        public int[] GldFbIdx
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->gld_fb_idx, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->gld_fb_idx[i] = value[i];
                }
            }
        }

        /// <summary>Altref buffer index.</summary>
        public int[] AltFbIdx
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->alt_fb_idx, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->alt_fb_idx[i] = value[i];
                }
            }
        }

        /// <summary>Update reference frames.</summary>
        public int[] UpdateBufferSlot
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->update_buffer_slot, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->update_buffer_slot[i] = value[i];
                }
            }
        }

        /// <summary>Update last.</summary>
        public int[] UpdateLast
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->update_last, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->update_last[i] = value[i];
                }
            }
        }

        /// <summary>Update golden.</summary>
        public int[] UpdateGolden
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->update_golden, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->update_golden[i] = value[i];
                }
            }
        }

        /// <summary>Update altref.</summary>
        public int[] UpdateAltRef
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->update_alt_ref, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->update_alt_ref[i] = value[i];
                }
            }
        }

        /// <summary>Last as reference.</summary>
        public int[] ReferenceLast
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->reference_last, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->reference_last[i] = value[i];
                }
            }
        }

        /// <summary>Golden as reference.</summary>
        public int[] ReferenceGolden
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->reference_golden, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->reference_golden[i] = value[i];
                }
            }
        }

        /// <summary>Altref as reference.</summary>
        public int[] ReferenceAltRef
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->reference_alt_ref, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->reference_alt_ref[i] = value[i];
                }
            }
        }

        /// <summary>Duration per spatial layer.</summary>
        public long[] Duration
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<long>(((__Internal*)__Instance)->duration, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->duration[i] = value[i];
                }
            }
        }
    }

    /// <summary>vp9 svc frame dropping parameters.</summary>
    /// <remarks>
    /// <para>This defines the frame drop thresholds for each spatial layer, and</para>
    /// <para>the frame dropping mode: 0 = layer based frame dropping (default),</para>
    /// <para>1 = constrained dropping where current layer drop forces all upper</para>
    /// <para>spatial layers to drop.</para>
    /// </remarks>
    public unsafe partial class VpxSvcFrameDrop : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            internal fixed int framedrop_thresh[5];
            internal global::Vpx.SVC_LAYER_DROP_MODE framedrop_mode;
            internal int max_consec_drop;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_svc_frame_drop@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxSvcFrameDrop> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxSvcFrameDrop>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxSvcFrameDrop managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxSvcFrameDrop managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxSvcFrameDrop __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxSvcFrameDrop(native.ToPointer(), skipVTables);
        }

        internal static VpxSvcFrameDrop __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxSvcFrameDrop)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxSvcFrameDrop __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxSvcFrameDrop(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxSvcFrameDrop(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxSvcFrameDrop(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxSvcFrameDrop()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxSvcFrameDrop.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxSvcFrameDrop(global::Vpx.VpxSvcFrameDrop _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxSvcFrameDrop.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxSvcFrameDrop.__Internal*) __Instance) = *((global::Vpx.VpxSvcFrameDrop.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Frame drop thresholds</summary>
        public int[] FramedropThresh
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->framedrop_thresh, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->framedrop_thresh[i] = value[i];
                }
            }
        }

        /// <summary>Layer-based or constrained dropping.</summary>
        public global::Vpx.SVC_LAYER_DROP_MODE FramedropMode
        {
            get
            {
                return ((__Internal*)__Instance)->framedrop_mode;
            }

            set
            {
                ((__Internal*)__Instance)->framedrop_mode = value;
            }
        }

        /// <summary>Maximum consecutive drops, for any layer.</summary>
        public int MaxConsecDrop
        {
            get
            {
                return ((__Internal*)__Instance)->max_consec_drop;
            }

            set
            {
                ((__Internal*)__Instance)->max_consec_drop = value;
            }
        }
    }

    /// <summary>vp9 svc spatial layer sync parameters.</summary>
    /// <remarks>This defines the spatial layer sync flag, defined per spatial layer.</remarks>
    public unsafe partial class VpxSvcSpatialLayerSync : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            internal fixed int spatial_layer_sync[5];
            internal int base_layer_intra_only;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_svc_spatial_layer_sync@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxSvcSpatialLayerSync> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxSvcSpatialLayerSync>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxSvcSpatialLayerSync managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxSvcSpatialLayerSync managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxSvcSpatialLayerSync __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxSvcSpatialLayerSync(native.ToPointer(), skipVTables);
        }

        internal static VpxSvcSpatialLayerSync __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxSvcSpatialLayerSync)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxSvcSpatialLayerSync __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxSvcSpatialLayerSync(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxSvcSpatialLayerSync(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxSvcSpatialLayerSync(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxSvcSpatialLayerSync()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxSvcSpatialLayerSync.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxSvcSpatialLayerSync(global::Vpx.VpxSvcSpatialLayerSync _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxSvcSpatialLayerSync.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxSvcSpatialLayerSync.__Internal*) __Instance) = *((global::Vpx.VpxSvcSpatialLayerSync.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Sync layer flags</summary>
        public int[] SpatialLayerSync
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->spatial_layer_sync, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->spatial_layer_sync[i] = value[i];
                }
            }
        }

        /// <summary>Flag for setting Intra-only frame on base</summary>
        public int BaseLayerIntraOnly
        {
            get
            {
                return ((__Internal*)__Instance)->base_layer_intra_only;
            }

            set
            {
                ((__Internal*)__Instance)->base_layer_intra_only = value;
            }
        }
    }

    public unsafe partial class vp8cx
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_vp8_cx", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr VpxCodecVp8Cx();

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_vp9_cx", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr VpxCodecVp9Cx();

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_ROI_MAP@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_roi_map@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_ROI_MAP(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_ACTIVEMAP@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_active_map@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_ACTIVEMAP(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_SCALEMODE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_scaling_mode@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_SCALEMODE(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_CPUUSED@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_CPUUSED(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_ENABLEAUTOALTREF@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_ENABLEAUTOALTREF(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_NOISE_SENSITIVITY@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_NOISE_SENSITIVITY(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_SHARPNESS@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_SHARPNESS(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_STATIC_THRESHOLD@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_STATIC_THRESHOLD(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_TOKEN_PARTITIONS@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_TOKEN_PARTITIONS(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_GET_LAST_QUANTIZER@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_GET_LAST_QUANTIZER(__IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_GET_LAST_QUANTIZER_64@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_GET_LAST_QUANTIZER_64(__IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_ARNR_MAXFRAMES@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_ARNR_MAXFRAMES(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_ARNR_STRENGTH@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_ARNR_STRENGTH(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_ARNR_TYPE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_ARNR_TYPE(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_TUNING@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_TUNING(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_CQ_LEVEL@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_CQ_LEVEL(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_MAX_INTRA_BITRATE_PCT@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_MAX_INTRA_BITRATE_PCT(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_FRAME_FLAGS@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_FRAME_FLAGS(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_MAX_INTER_BITRATE_PCT@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_MAX_INTER_BITRATE_PCT(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_GF_CBR_BOOST_PCT@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_GF_CBR_BOOST_PCT(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_TEMPORAL_LAYER_ID@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_TEMPORAL_LAYER_ID(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_SCREEN_CONTENT_MODE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_SCREEN_CONTENT_MODE(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_LOSSLESS@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_LOSSLESS(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_TILE_COLUMNS@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_TILE_COLUMNS(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_TILE_ROWS@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_TILE_ROWS(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_FRAME_PARALLEL_DECODING@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_FRAME_PARALLEL_DECODING(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_AQ_MODE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_AQ_MODE(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_FRAME_PERIODIC_BOOST@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_FRAME_PERIODIC_BOOST(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_NOISE_SENSITIVITY@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_NOISE_SENSITIVITY(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_SVC@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_SVC(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_ROI_MAP@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_roi_map@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_ROI_MAP(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_SVC_PARAMETERS@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_PARAMETERS(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_SVC_LAYER_ID@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_svc_layer_id@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_LAYER_ID(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_TUNE_CONTENT@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_TUNE_CONTENT(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_GET_SVC_LAYER_ID@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_svc_layer_id@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_GET_SVC_LAYER_ID(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_REGISTER_CX_CALLBACK@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAX@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_REGISTER_CX_CALLBACK(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_COLOR_SPACE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_COLOR_SPACE(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_MIN_GF_INTERVAL@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_MIN_GF_INTERVAL(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_MAX_GF_INTERVAL@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_MAX_GF_INTERVAL(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_GET_ACTIVEMAP@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_active_map@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_GET_ACTIVEMAP(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_COLOR_RANGE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_COLOR_RANGE(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_SVC_REF_FRAME_CONFIG@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_svc_ref_frame_config@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_REF_FRAME_CONFIG(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_RENDER_SIZE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_RENDER_SIZE(__IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_TARGET_LEVEL@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_TARGET_LEVEL(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_ROW_MT@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_ROW_MT(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_GET_LEVEL@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_GET_LEVEL(__IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_ALT_REF_AQ@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_ALT_REF_AQ(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_GF_CBR_BOOST_PCT@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_GF_CBR_BOOST_PCT(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_ENABLE_MOTION_VECTOR_UNIT_TEST@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_ENABLE_MOTION_VECTOR_UNIT_TEST(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_SVC_INTER_LAYER_PRED@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_INTER_LAYER_PRED(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_SVC_FRAME_DROP_LAYER@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_svc_frame_drop@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_FRAME_DROP_LAYER(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_GET_SVC_REF_FRAME_CONFIG@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_svc_ref_frame_config@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_GET_SVC_REF_FRAME_CONFIG(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_SVC_GF_TEMPORAL_REF@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_GF_TEMPORAL_REF(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_SVC_SPATIAL_LAYER_SYNC@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_svc_spatial_layer_sync@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_SPATIAL_LAYER_SYNC(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_TPL@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_TPL(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_POSTENCODE_DROP@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_POSTENCODE_DROP(__IntPtr _0, int _1, uint _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_DELTA_Q_UV@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_DELTA_Q_UV(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_DISABLE_OVERSHOOT_MAXQ_CBR@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_DISABLE_OVERSHOOT_MAXQ_CBR(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_DISABLE_LOOPFILTER@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_DISABLE_LOOPFILTER(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_EXTERNAL_RATE_CONTROL@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_rc_funcs@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_EXTERNAL_RATE_CONTROL(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_RTC_EXTERNAL_RATECTRL@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_RTC_EXTERNAL_RATECTRL(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_GET_LOOPFILTER_LEVEL@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_GET_LOOPFILTER_LEVEL(__IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_GET_LAST_QUANTIZER_SVC_LAYERS@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_GET_LAST_QUANTIZER_SVC_LAYERS(__IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8E_SET_RTC_EXTERNAL_RATECTRL@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_RTC_EXTERNAL_RATECTRL(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9E_SET_QUANTIZER_ONE_PASS@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_QUANTIZER_ONE_PASS(__IntPtr _0, int _1, int _2);
        }

        /// <summary>The interface to the VP8 encoder.</summary>
        public static global::Vpx.VpxCodecIface VpxCodecVp8Cx()
        {
            var ___ret = __Internal.VpxCodecVp8Cx();
            var __result0 = global::Vpx.VpxCodecIface.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>The interface to the VP9 encoder.</summary>
        public static global::Vpx.VpxCodecIface VpxCodecVp9Cx()
        {
            var ___ret = __Internal.VpxCodecVp9Cx();
            var __result0 = global::Vpx.VpxCodecIface.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_ROI_MAP(global::Vpx.VpxCodecCtx _0, int _1, global::Vpx.VpxRoiMap _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_ROI_MAP(__arg0, _1, __arg2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_ACTIVEMAP(global::Vpx.VpxCodecCtx _0, int _1, global::Vpx.VpxActiveMap _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_ACTIVEMAP(__arg0, _1, __arg2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_SCALEMODE(global::Vpx.VpxCodecCtx _0, int _1, global::Vpx.VpxScalingMode _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_SCALEMODE(__arg0, _1, __arg2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_CPUUSED(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_CPUUSED(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_ENABLEAUTOALTREF(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_ENABLEAUTOALTREF(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_NOISE_SENSITIVITY(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_NOISE_SENSITIVITY(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_SHARPNESS(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_SHARPNESS(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_STATIC_THRESHOLD(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_STATIC_THRESHOLD(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_TOKEN_PARTITIONS(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_TOKEN_PARTITIONS(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_GET_LAST_QUANTIZER(global::Vpx.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var ___ret = __Internal.VpxCodecControlVP8E_GET_LAST_QUANTIZER(__arg0, _1, __arg2);
                return ___ret;
            }
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_GET_LAST_QUANTIZER_64(global::Vpx.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var ___ret = __Internal.VpxCodecControlVP8E_GET_LAST_QUANTIZER_64(__arg0, _1, __arg2);
                return ___ret;
            }
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_ARNR_MAXFRAMES(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_ARNR_MAXFRAMES(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_ARNR_STRENGTH(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_ARNR_STRENGTH(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_ARNR_TYPE(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_ARNR_TYPE(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_TUNING(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_TUNING(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_CQ_LEVEL(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_CQ_LEVEL(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_MAX_INTRA_BITRATE_PCT(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_MAX_INTRA_BITRATE_PCT(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_FRAME_FLAGS(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_FRAME_FLAGS(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_MAX_INTER_BITRATE_PCT(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_MAX_INTER_BITRATE_PCT(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_GF_CBR_BOOST_PCT(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_GF_CBR_BOOST_PCT(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_TEMPORAL_LAYER_ID(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_TEMPORAL_LAYER_ID(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_SCREEN_CONTENT_MODE(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_SCREEN_CONTENT_MODE(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_LOSSLESS(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_LOSSLESS(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_TILE_COLUMNS(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_TILE_COLUMNS(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_TILE_ROWS(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_TILE_ROWS(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_FRAME_PARALLEL_DECODING(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_FRAME_PARALLEL_DECODING(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_AQ_MODE(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_AQ_MODE(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_FRAME_PERIODIC_BOOST(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_FRAME_PERIODIC_BOOST(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_NOISE_SENSITIVITY(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_NOISE_SENSITIVITY(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_SVC(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_SVC(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_ROI_MAP(global::Vpx.VpxCodecCtx _0, int _1, global::Vpx.VpxRoiMap _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_ROI_MAP(__arg0, _1, __arg2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_PARAMETERS(global::Vpx.VpxCodecCtx _0, int _1, __IntPtr _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_SVC_PARAMETERS(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_LAYER_ID(global::Vpx.VpxCodecCtx _0, int _1, global::Vpx.VpxSvcLayerId _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_SVC_LAYER_ID(__arg0, _1, __arg2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_TUNE_CONTENT(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_TUNE_CONTENT(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_GET_SVC_LAYER_ID(global::Vpx.VpxCodecCtx _0, int _1, global::Vpx.VpxSvcLayerId _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_GET_SVC_LAYER_ID(__arg0, _1, __arg2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_REGISTER_CX_CALLBACK(global::Vpx.VpxCodecCtx _0, int _1, __IntPtr _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_REGISTER_CX_CALLBACK(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_COLOR_SPACE(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_COLOR_SPACE(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_MIN_GF_INTERVAL(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_MIN_GF_INTERVAL(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_MAX_GF_INTERVAL(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_MAX_GF_INTERVAL(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_GET_ACTIVEMAP(global::Vpx.VpxCodecCtx _0, int _1, global::Vpx.VpxActiveMap _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_GET_ACTIVEMAP(__arg0, _1, __arg2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_COLOR_RANGE(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_COLOR_RANGE(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_REF_FRAME_CONFIG(global::Vpx.VpxCodecCtx _0, int _1, global::Vpx.VpxSvcRefFrameConfig _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_SVC_REF_FRAME_CONFIG(__arg0, _1, __arg2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_RENDER_SIZE(global::Vpx.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var ___ret = __Internal.VpxCodecControlVP9E_SET_RENDER_SIZE(__arg0, _1, __arg2);
                return ___ret;
            }
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_TARGET_LEVEL(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_TARGET_LEVEL(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_ROW_MT(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_ROW_MT(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_GET_LEVEL(global::Vpx.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var ___ret = __Internal.VpxCodecControlVP9E_GET_LEVEL(__arg0, _1, __arg2);
                return ___ret;
            }
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_ALT_REF_AQ(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_ALT_REF_AQ(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_GF_CBR_BOOST_PCT(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_GF_CBR_BOOST_PCT(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_ENABLE_MOTION_VECTOR_UNIT_TEST(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_ENABLE_MOTION_VECTOR_UNIT_TEST(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_INTER_LAYER_PRED(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_SVC_INTER_LAYER_PRED(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_FRAME_DROP_LAYER(global::Vpx.VpxCodecCtx _0, int _1, global::Vpx.VpxSvcFrameDrop _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_SVC_FRAME_DROP_LAYER(__arg0, _1, __arg2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_GET_SVC_REF_FRAME_CONFIG(global::Vpx.VpxCodecCtx _0, int _1, global::Vpx.VpxSvcRefFrameConfig _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_GET_SVC_REF_FRAME_CONFIG(__arg0, _1, __arg2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_GF_TEMPORAL_REF(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_SVC_GF_TEMPORAL_REF(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_SVC_SPATIAL_LAYER_SYNC(global::Vpx.VpxCodecCtx _0, int _1, global::Vpx.VpxSvcSpatialLayerSync _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_SVC_SPATIAL_LAYER_SYNC(__arg0, _1, __arg2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_TPL(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_TPL(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_POSTENCODE_DROP(global::Vpx.VpxCodecCtx _0, int _1, uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_POSTENCODE_DROP(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_DELTA_Q_UV(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_DELTA_Q_UV(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_DISABLE_OVERSHOOT_MAXQ_CBR(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_DISABLE_OVERSHOOT_MAXQ_CBR(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_DISABLE_LOOPFILTER(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_DISABLE_LOOPFILTER(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_EXTERNAL_RATE_CONTROL(global::Vpx.VpxCodecCtx _0, int _1, global::Vpx.VpxRcFuncs _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_EXTERNAL_RATE_CONTROL(__arg0, _1, __arg2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_RTC_EXTERNAL_RATECTRL(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_RTC_EXTERNAL_RATECTRL(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_GET_LOOPFILTER_LEVEL(global::Vpx.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var ___ret = __Internal.VpxCodecControlVP9E_GET_LOOPFILTER_LEVEL(__arg0, _1, __arg2);
                return ___ret;
            }
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_GET_LAST_QUANTIZER_SVC_LAYERS(global::Vpx.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var ___ret = __Internal.VpxCodecControlVP9E_GET_LAST_QUANTIZER_SVC_LAYERS(__arg0, _1, __arg2);
                return ___ret;
            }
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8E_SET_RTC_EXTERNAL_RATECTRL(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8E_SET_RTC_EXTERNAL_RATECTRL(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9E_SET_QUANTIZER_ONE_PASS(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9E_SET_QUANTIZER_ONE_PASS(__arg0, _1, _2);
            return ___ret;
        }
    }

    /// <summary>VP8 decoder control functions</summary>
    /// <remarks>
    /// <para>This set of macros define the control functions available for the VP8</para>
    /// <para>decoder interface.</para>
    /// <para>#vpx_codec_control</para>
    /// </remarks>
    public enum Vp8DecControlId
    {
        /// <summary>
        /// <para>control function to get info on which reference frames were updated</para>
        /// <para>by the last decode</para>
        /// </summary>
        VP8D_GET_LAST_REF_UPDATES = 256,
        /// <summary>check if the indicated frame is corrupted</summary>
        VP8D_GET_FRAME_CORRUPTED = 257,
        /// <summary>
        /// <para>control function to get info on which reference frames were used</para>
        /// <para>by the last decode</para>
        /// </summary>
        VP8D_GET_LAST_REF_USED = 258,
        /// <summary>
        /// <para>decryption function to decrypt encoded buffer data immediately</para>
        /// <para>before decoding. Takes a vpx_decrypt_init, which contains</para>
        /// <para>a callback function and opaque context pointer.</para>
        /// </summary>
        VPXD_SET_DECRYPTOR = 259,
        /// <summary>
        /// <para>decryption function to decrypt encoded buffer data immediately</para>
        /// <para>before decoding. Takes a vpx_decrypt_init, which contains</para>
        /// <para>a callback function and opaque context pointer.</para>
        /// </summary>
        VP8D_SET_DECRYPTOR = 259,
        /// <summary>
        /// <para>control function to get the dimensions that the current frame is decoded</para>
        /// <para>at. This may be different to the intended display size for the frame as</para>
        /// <para>specified in the wrapper or frame header (see VP9D_GET_DISPLAY_SIZE).</para>
        /// </summary>
        VP9D_GET_FRAME_SIZE = 260,
        /// <summary>
        /// <para>control function to get the current frame's intended display dimensions</para>
        /// <para>(as specified in the wrapper or frame header). This may be different to</para>
        /// <para>the decoded dimensions of this frame (see VP9D_GET_FRAME_SIZE).</para>
        /// </summary>
        VP9D_GET_DISPLAY_SIZE = 261,
        /// <summary>control function to get the bit depth of the stream.</summary>
        VP9D_GET_BIT_DEPTH = 262,
        /// <summary>
        /// <para>control function to set the byte alignment of the planes in the reference</para>
        /// <para>buffers. Valid values are power of 2, from 32 to 1024. A value of 0 sets</para>
        /// <para>legacy alignment. I.e. Y plane is aligned to 32 bytes, U plane directly</para>
        /// <para>follows Y plane, and V plane directly follows U plane. Default value is 0.</para>
        /// </summary>
        VP9SET_BYTE_ALIGNMENT = 263,
        /// <summary>
        /// <para>control function to invert the decoding order to from right to left. The</para>
        /// <para>function is used in a test to confirm the decoding independence of tile</para>
        /// <para>columns. The function may be used in application where this order</para>
        /// <para>of decoding is desired.</para>
        /// </summary>
        /// <remarks>
        /// <para>TODO(yaowu): Rework the unit test that uses this control, and in a future</para>
        /// <para>release, this test-only control shall be removed.</para>
        /// </remarks>
        VP9INVERT_TILE_DECODE_ORDER = 264,
        /// <summary>
        /// <para>control function to set the skip loop filter flag. Valid values are</para>
        /// <para>integers. The decoder will skip the loop filter when its value is set to</para>
        /// <para>nonzero. If the loop filter is skipped the decoder may accumulate decode</para>
        /// <para>artifacts. The default value is 0.</para>
        /// </summary>
        VP9SET_SKIP_LOOP_FILTER = 265,
        /// <summary>
        /// <para>control function to decode SVC stream up to the x spatial layers,</para>
        /// <para>where x is passed in through the control, and is 0 for base layer.</para>
        /// </summary>
        VP9DECODE_SVC_SPATIAL_LAYER = 266,
        /// <summary>Codec control function to get last decoded frame quantizer.</summary>
        /// <remarks>
        /// <para>Return value uses internal quantizer scale defined by the codec.</para>
        /// <para>Supported in codecs: VP8, VP9</para>
        /// </remarks>
        VPXD_GET_LAST_QUANTIZER = 267,
        /// <summary>Codec control function to set row level multi-threading.</summary>
        /// <remarks>
        /// <para>0 : off, 1 : on</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9D_SET_ROW_MT = 268,
        /// <summary>Codec control function to set loopfilter optimization.</summary>
        /// <remarks>
        /// <para>0 : off, Loop filter is done after all tiles have been decoded</para>
        /// <para>1 : on, Loop filter is done immediately after decode without</para>
        /// <para>waiting for all threads to sync.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP9D_SET_LOOP_FILTER_OPT = 269,
        /// <summary>Codec control function to set loopfilter optimization.</summary>
        /// <remarks>
        /// <para>0 : off, Loop filter is done after all tiles have been decoded</para>
        /// <para>1 : on, Loop filter is done immediately after decode without</para>
        /// <para>waiting for all threads to sync.</para>
        /// <para>Supported in codecs: VP9</para>
        /// </remarks>
        VP8DECODER_CTRL_ID_MAX = 270
    }

    /// <summary>
    /// <para>Decrypt n bytes of data from input -&gt; output, using the decrypt_state</para>
    /// <para>passed in VPXD_SET_DECRYPTOR.</para>
    /// </summary>
    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void VpxDecryptCb(__IntPtr decrypt_state, byte* input, byte* output, int count);

    /// <summary>Structure to hold decryption state</summary>
    /// <remarks>Defines a structure to hold the decryption state and access function.</remarks>
    /// <summary>Structure to hold decryption state</summary>
    /// <remarks>Defines a structure to hold the decryption state and access function.</remarks>
    public unsafe partial class VpxDecryptInit : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr decrypt_cb;
            internal __IntPtr decrypt_state;

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "??0vpx_decrypt_init@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxDecryptInit> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Vpx.VpxDecryptInit>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::Vpx.VpxDecryptInit managed)
        {
            NativeToManagedMap[native] = managed;
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::Vpx.VpxDecryptInit managed)
        {
    
            return NativeToManagedMap.TryGetValue(native, out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VpxDecryptInit __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            return new VpxDecryptInit(native.ToPointer(), skipVTables);
        }

        internal static VpxDecryptInit __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VpxDecryptInit)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VpxDecryptInit __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VpxDecryptInit(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VpxDecryptInit(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        protected VpxDecryptInit(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VpxDecryptInit()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxDecryptInit.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VpxDecryptInit(global::Vpx.VpxDecryptInit _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::Vpx.VpxDecryptInit.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::Vpx.VpxDecryptInit.__Internal*) __Instance) = *((global::Vpx.VpxDecryptInit.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>Decrypt callback.</summary>
        public global::Vpx.VpxDecryptCb DecryptCb
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->decrypt_cb;
                return __ptr0 == IntPtr.Zero? null : (global::Vpx.VpxDecryptCb) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::Vpx.VpxDecryptCb));
            }

            set
            {
                ((__Internal*)__Instance)->decrypt_cb = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        /// <summary>Decryption state.</summary>
        public __IntPtr DecryptState
        {
            get
            {
                return ((__Internal*)__Instance)->decrypt_state;
            }

            set
            {
                ((__Internal*)__Instance)->decrypt_state = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class vp8dx
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_vp8_dx", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr VpxCodecVp8Dx();

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "vpx_codec_vp9_dx", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr VpxCodecVp9Dx();

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8D_GET_LAST_REF_UPDATES@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8D_GET_LAST_REF_UPDATES(__IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8D_GET_FRAME_CORRUPTED@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8D_GET_FRAME_CORRUPTED(__IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8D_GET_LAST_REF_USED@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8D_GET_LAST_REF_USED(__IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VPXD_SET_DECRYPTOR@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_decrypt_init@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVPXD_SET_DECRYPTOR(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP8D_SET_DECRYPTOR@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAUvpx_decrypt_init@@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP8D_SET_DECRYPTOR(__IntPtr _0, int _1, __IntPtr _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9D_GET_FRAME_SIZE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9D_GET_FRAME_SIZE(__IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9D_GET_DISPLAY_SIZE@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9D_GET_DISPLAY_SIZE(__IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9D_GET_BIT_DEPTH@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAI@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9D_GET_BIT_DEPTH(__IntPtr _0, int _1, uint* _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9_SET_BYTE_ALIGNMENT@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9SET_BYTE_ALIGNMENT(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9_INVERT_TILE_DECODE_ORDER@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9INVERT_TILE_DECODE_ORDER(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9_SET_SKIP_LOOP_FILTER@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9SET_SKIP_LOOP_FILTER(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9_DECODE_SVC_SPATIAL_LAYER@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9DECODE_SVC_SPATIAL_LAYER(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VPXD_GET_LAST_QUANTIZER@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HPEAH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVPXD_GET_LAST_QUANTIZER(__IntPtr _0, int _1, int* _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9D_SET_ROW_MT@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9D_SET_ROW_MT(__IntPtr _0, int _1, int _2);

            [SuppressUnmanagedCodeSecurity, DllImport("Vpx", EntryPoint = "?vpx_codec_control_VP9D_SET_LOOP_FILTER_OPT@@YA?AW4vpx_codec_err_t@@PEAUvpx_codec_ctx@@HH@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::Vpx.VpxCodecErrT VpxCodecControlVP9D_SET_LOOP_FILTER_OPT(__IntPtr _0, int _1, int _2);
        }

        /// <summary>The interface to the VP8 decoder.</summary>
        public static global::Vpx.VpxCodecIface VpxCodecVp8Dx()
        {
            var ___ret = __Internal.VpxCodecVp8Dx();
            var __result0 = global::Vpx.VpxCodecIface.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        /// <summary>The interface to the VP9 decoder.</summary>
        public static global::Vpx.VpxCodecIface VpxCodecVp9Dx()
        {
            var ___ret = __Internal.VpxCodecVp9Dx();
            var __result0 = global::Vpx.VpxCodecIface.__GetOrCreateInstance(___ret, false);
            return __result0;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8D_GET_LAST_REF_UPDATES(global::Vpx.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var ___ret = __Internal.VpxCodecControlVP8D_GET_LAST_REF_UPDATES(__arg0, _1, __arg2);
                return ___ret;
            }
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8D_GET_FRAME_CORRUPTED(global::Vpx.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var ___ret = __Internal.VpxCodecControlVP8D_GET_FRAME_CORRUPTED(__arg0, _1, __arg2);
                return ___ret;
            }
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8D_GET_LAST_REF_USED(global::Vpx.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var ___ret = __Internal.VpxCodecControlVP8D_GET_LAST_REF_USED(__arg0, _1, __arg2);
                return ___ret;
            }
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVPXD_SET_DECRYPTOR(global::Vpx.VpxCodecCtx _0, int _1, global::Vpx.VpxDecryptInit _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
            var ___ret = __Internal.VpxCodecControlVPXD_SET_DECRYPTOR(__arg0, _1, __arg2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP8D_SET_DECRYPTOR(global::Vpx.VpxCodecCtx _0, int _1, global::Vpx.VpxDecryptInit _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var __arg2 = _2 is null ? __IntPtr.Zero : _2.__Instance;
            var ___ret = __Internal.VpxCodecControlVP8D_SET_DECRYPTOR(__arg0, _1, __arg2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9D_GET_FRAME_SIZE(global::Vpx.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var ___ret = __Internal.VpxCodecControlVP9D_GET_FRAME_SIZE(__arg0, _1, __arg2);
                return ___ret;
            }
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9D_GET_DISPLAY_SIZE(global::Vpx.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var ___ret = __Internal.VpxCodecControlVP9D_GET_DISPLAY_SIZE(__arg0, _1, __arg2);
                return ___ret;
            }
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9D_GET_BIT_DEPTH(global::Vpx.VpxCodecCtx _0, int _1, ref uint _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            fixed (uint* ___22 = &_2)
            {
                var __arg2 = ___22;
                var ___ret = __Internal.VpxCodecControlVP9D_GET_BIT_DEPTH(__arg0, _1, __arg2);
                return ___ret;
            }
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9SET_BYTE_ALIGNMENT(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9SET_BYTE_ALIGNMENT(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9INVERT_TILE_DECODE_ORDER(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9INVERT_TILE_DECODE_ORDER(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9SET_SKIP_LOOP_FILTER(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9SET_SKIP_LOOP_FILTER(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9DECODE_SVC_SPATIAL_LAYER(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9DECODE_SVC_SPATIAL_LAYER(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVPXD_GET_LAST_QUANTIZER(global::Vpx.VpxCodecCtx _0, int _1, ref int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            fixed (int* ___22 = &_2)
            {
                var __arg2 = ___22;
                var ___ret = __Internal.VpxCodecControlVPXD_GET_LAST_QUANTIZER(__arg0, _1, __arg2);
                return ___ret;
            }
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9D_SET_ROW_MT(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9D_SET_ROW_MT(__arg0, _1, _2);
            return ___ret;
        }

        public static global::Vpx.VpxCodecErrT VpxCodecControlVP9D_SET_LOOP_FILTER_OPT(global::Vpx.VpxCodecCtx _0, int _1, int _2)
        {
            var __arg0 = _0 is null ? __IntPtr.Zero : _0.__Instance;
            var ___ret = __Internal.VpxCodecControlVP9D_SET_LOOP_FILTER_OPT(__arg0, _1, _2);
            return ___ret;
        }
    }
}
